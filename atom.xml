<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maintel&#39;s notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://maintel.github.io/"/>
  <updated>2018-03-22T16:55:13.049Z</updated>
  <id>https://maintel.github.io/</id>
  
  <author>
    <name>Maintel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxJava操作符 —— 过滤</title>
    <link href="https://maintel.github.io//blog/2018/03/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A62.html"/>
    <id>https://maintel.github.io//blog/2018/03/RxJava操作符2.html</id>
    <published>2018-03-18T11:51:51.000Z</published>
    <updated>2018-03-22T16:55:13.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本系列旨在整理总结 RxJava 2 的操作符，以供大家参考。本文内容 —— 过滤操作符。</p>
<p>其他文章可查阅：</p>
<ul>
<li><a href="https://blog.maintel.cn/blog/2018/03/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6.html" target="_blank" rel="external">RxJava操作符 —— 创建和变换</a></li>
</ul>
<h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>过滤操作符用来过滤和选择 Obserbale 发射的序列。<a href="https://github.com/maintel/KotlinTest/blob/master/app/src/test/java/com/demo/kotlintest/RxJavaFilteringTest.kt" target="_blank" rel="external">示例代码</a></p>
<h2 id="Debounce"><a href="#Debounce" class="headerlink" title="Debounce"></a><a href="http://reactivex.io/documentation/operators/debounce.html" target="_blank" rel="external">Debounce</a></h2><p>在特定时间内如果没有发射数据，就将当前可观察的最后一条数据发射出去。<br><img src="https://raw.githubusercontent.com/wiki/ReactiveX/RxJava/images/rx-operators/debounce.png" alt="Debounce"></p>
<h2 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a><a href="http://reactivex.io/documentation/operators/distinct.html" target="_blank" rel="external">Distinct</a></h2><p>去除 Observable 发射出的重复项。</p>
<p>在 rxJava 2 中有两个实现：</p>
<ul>
<li><p><code>distinct</code><br>  默认实现。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinct.png" alt="distinct"></p>
<p>  而且有一些重载，比如通过一个函数来自己指定相应的 key，如果消息序列中有 key 相同的项，则保留第一项。</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>)</div><div class="line">        .distinct &#123; t -&gt;</div><div class="line">            <span class="keyword">when</span> &#123;</div><div class="line">                t &lt; <span class="number">3</span> -&gt; <span class="keyword">return</span><span class="symbol">@distinct</span> <span class="string">"a"</span></div><div class="line">                t <span class="keyword">in</span> <span class="number">3.</span><span class="number">.4</span> -&gt; <span class="keyword">return</span><span class="symbol">@distinct</span> <span class="string">"b"</span></div><div class="line">                <span class="keyword">else</span> -&gt; <span class="keyword">return</span><span class="symbol">@distinct</span> <span class="string">"c"</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        .subscribe &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>distinctUntilChanged</code><br>  只去除掉连续的重复项。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/distinctUntilChanged.png" alt="distinctUntilChanged"></p>
</li>
</ul>
<h2 id="ElementAt"><a href="#ElementAt" class="headerlink" title="ElementAt"></a><a href="http://reactivex.io/documentation/operators/elementat.html" target="_blank" rel="external">ElementAt</a></h2><p>仅让第 n 个消息通过发射，其他的消息均被丢弃掉。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/elementAt.2m.png" alt="ElementAt"></p>
<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a><a href="http://reactivex.io/documentation/operators/filter.html" target="_blank" rel="external">Filter</a></h2><p>过滤掉不符合条件的消息，只发送符合条件的消息。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/filter.png" alt="Filter"></p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .filter &#123; t -&gt; t &lt; <span class="number">3</span> &#125;</div><div class="line">        .subscribe &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
<p>还有一个操作符是 ofType，检查消息的类型，不符合类型的消息将会被丢掉<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ofClass.png" alt="ofType"><br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不过注意 比如这里发送的 消息并不是 kotlin 的 Int 型 而是 java 的 Integer 类型</span></div><div class="line">Observable.just(<span class="number">1</span>, <span class="number">5</span>, <span class="string">""</span>, <span class="number">4</span>, <span class="string">"aa"</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>)</div><div class="line">        .ofType(Class.forName(<span class="string">"java.lang.Integer"</span>))</div><div class="line">        .subscribe &#123; value -&gt;</div><div class="line">            println(value.javaClass)</div><div class="line">            println(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="First"><a href="#First" class="headerlink" title="First"></a><a href="http://reactivex.io/documentation/operators/first.html" target="_blank" rel="external">First</a></h2><p>只发送可观察到的第一个消息，或者是符合条件的第一个消息，需要注意的是 first 返回的是一个 Single 对象。</p>
<p>在 rxJava 2 中有以下几个实现</p>
<ul>
<li><code>blockingFirst</code><br>  只发射第一个消息，如果为空且没有默认值就抛出一个异常 <code>NoSuchElementException</code>，需要注意的是它的返回值，不再是一个 Observable 或 Single，而是一个泛型。</li>
<li><code>blockingSingle</code><br>  如果 observable 发射一个消息以后完成了发射（即消息序列中只有一个消息），就返回这一个消息；如果后面还有消息发射，就抛出异常 <code>NoSuchElementException</code>。<br>  <img src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.single.png" alt="blockingSingle"></li>
<li><code>firstElement</code><br>  只发射第一个消息，其实和 ElementAt(0) 是一样的。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/firstElement.png" alt="firstElement"></li>
<li><code>first</code><br>  只发射第一个消息，如果为空就发送默认值。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/first.2.png" alt="first"></li>
<li><code>single</code><br>  原始 observable 只能发射一个或者不发射消息，否则就会报错，如果是空数据，就将 single 中的默认值发射出去。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/single.2.png" alt="single"></li>
<li><code>singleElement</code><br>  原始 observable 只能发射一个消息，如果为空或者多个消息就抛出异常。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/singleElement.png" alt="singleElement"></li>
</ul>
<h2 id="IgnoreElements"><a href="#IgnoreElements" class="headerlink" title="IgnoreElements"></a><a href="http://reactivex.io/documentation/operators/ignoreelements.html" target="_blank" rel="external">IgnoreElements</a></h2><p>IgnoreElements 操作符确保 observable 不发射任何数据，只发射 observable 的终止通知。即它过滤掉 onNext，只会使 onError 或者 onComplete 被触发。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/ignoreElements.2.png" alt="IgnoreElements"></p>
<h2 id="Last"><a href="#Last" class="headerlink" title="Last"></a><a href="http://reactivex.io/documentation/operators/last.html" target="_blank" rel="external">Last</a></h2><p>只发射 observable 的最后一项数据或者符合条件的最后一项数据。</p>
<p>Last 在 RxJava 2 中有以下几个实现：</p>
<ul>
<li><code>lastElement</code><br>  发射 observable 的最后一项，如果当前 observable 为空则直接执行 onComplete。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/lastElement.png" alt="lastElement"></li>
<li><code>last</code><br>  只发射 observable 的最后一项，如果为空则将 last(defaultItem) 中 defaultItem 发射出去。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/last.2.png" alt="last"></li>
<li><code>blockingLast</code><br>  返回最后一项数据，在这之前会一直阻塞住线程，（这个操作符使用线程调度好像不起作用，还是会阻塞原有线程）,如果不指定默认值，且原始 observable 为空则抛出一个 NoSuchElementException 异常，如果指定了默认值就返回默认值。<br>  <img src="https://github.com/ReactiveX/RxJava/wiki/images/rx-operators/B.last.png" alt="blockingLast">  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">thread &#123;</div><div class="line">    println(System.currentTimeMillis())</div><div class="line">    Observable.intervalRange(<span class="number">1</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">            .subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(Schedulers.newThread()) <span class="comment">//即使这里指定了在新线程，他还是阻塞了原始的线程</span></div><div class="line">            .blockingLast()</div><div class="line">    println(System.currentTimeMillis())</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a><a href="http://reactivex.io/documentation/operators/sample.html" target="_blank" rel="external">Sample</a></h2><p>周期性的将原始 observable 中当前周期内发射的最后一条消息发射出去。</p>
<p>在 rxJava 2 中有以下实现：</p>
<ul>
<li><code>sample</code><br>  默认实现，周期性的将原始 observable 中当前周期内发射的最后一条消息发射出去，而且只发射一次。可以看到下图中第三个周期并没有发射数据。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/sample.png" alt="sample"></li>
<li><code>throttleFirst</code><br>  周期性的将原始 observable 中的当前周期内的第一条消息发射出去。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleFirst.png" alt="throttleFirst"></li>
<li><code>throttleLast</code><br>  周期性的将原始 observable 中当前周期内发射的最后一条消息发射出去，其实这个在内部实现就是 sample。<br>  <img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/throttleLast.png" alt="throttleLast"></li>
</ul>
<h2 id="Skip"><a href="#Skip" class="headerlink" title="Skip"></a><a href="http://reactivex.io/documentation/operators/skip.html" target="_blank" rel="external">Skip</a></h2><p>跳过 observable 开始的几项。rxJava 的强大之处在于 skip 不但可以在空间维度上跳过一些项，也可以指定在时间维度上跳过一些项。</p>
<p><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skip.png" alt="Skip"></p>
<h2 id="SkipLast"><a href="#SkipLast" class="headerlink" title="SkipLast"></a><a href="http://reactivex.io/documentation/operators/skiplast.html" target="_blank" rel="external">SkipLast</a></h2><p>跳过 observable 的最后几项，和 skip 一样，不但可以指定空间维度，还可以指定时间维度。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/skipLast.png" alt="SkipLast"></p>
<h2 id="Take"><a href="#Take" class="headerlink" title="Take"></a><a href="http://reactivex.io/documentation/operators/take.html" target="_blank" rel="external">Take</a></h2><p>只发送 observable 的前几项，和 skip 一样，不但可以指定空间维度，还可以指定时间维度。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/take.png" alt="Take"></p>
<h2 id="TakeLast"><a href="#TakeLast" class="headerlink" title="TakeLast"></a><a href="http://reactivex.io/documentation/operators/takelast.html" target="_blank" rel="external">TakeLast</a></h2><p>只发送 observable 的前几项，和 skip 一样，不但可以指定空间维度，还可以指定时间维度。<br><img src="https://raw.github.com/wiki/ReactiveX/RxJava/images/rx-operators/takeLast.tn.png" alt="TakeLast"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是 rxJava 2 中所有的过滤操作符，下面会接着来说结合操作符。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本系列旨在整理总结 RxJava 2 的操作符，以供大家参考。本文内容 —— 过滤操作符。&lt;/p&gt;
&lt;p&gt;其他文章可查阅：&lt;/p&gt;
&lt;ul&gt;
    
    </summary>
    
      <category term="开源" scheme="https://maintel.github.io/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="RxJava" scheme="https://maintel.github.io/tags/RxJava/"/>
    
      <category term="操作符" scheme="https://maintel.github.io/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava操作符 —— 创建和变换</title>
    <link href="https://maintel.github.io//blog/2018/03/RxJava%E6%93%8D%E4%BD%9C%E7%AC%A6.html"/>
    <id>https://maintel.github.io//blog/2018/03/RxJava操作符.html</id>
    <published>2018-03-13T03:21:49.000Z</published>
    <updated>2018-03-22T16:55:52.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>从前年开始使用 RxJava，后来换了工作以后虽然项目中一样使用了 RxJava 但是工作的侧重点更多的转向了前端上面，现在重新回到源生上再看 RxJava 发现之前的使用都是非常基础的，RxJava 提供的如此之多的操作符却基本上只用了那么几个，由于了解的比较少自然而然的使用过程中也会限制到使用 RxJava 解决问题的能力，所以参考 RxJava 的官方文档把几乎所有的操作符都实现了一遍，现在再把这些整理一下以供自己后面随时翻阅，也可以为别人提供一下参考。</p>
<p>需要说明的是我使用的是 RxJava 2.0.1，所有的例子都是使用 kotlin 来是实现的，所以很多地方使用了 lambda 表达式还请注意。关于 kotlin 的 lambda 表达式请参考<a href="http://www.kotlincn.net/docs/reference/lambdas.html" target="_blank" rel="external">这里</a></p>
<p>关于 RxJava 的文章网上一搜一大把，有讲原理的有讲使用的不一而足这里推荐几个个人认为比较好的：</p>
<ul>
<li><a href="https://www.jianshu.com/p/a93c79e9f689" target="_blank" rel="external">这可能是最好的RxJava 2.x 入门教程</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给 Android 开发者的 RxJava 详解– rx1.0</a></li>
<li><a href="https://zouzhberk.github.io/rxjava-study/" target="_blank" rel="external">RxJava2 响应式编程介绍</a></li>
<li><a href="http://reactivex.io/" target="_blank" rel="external">官方网站</a></li>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/" target="_blank" rel="external">中文翻译版文档</a></li>
</ul>
<p>以上</p>
<h1 id="创建操作符"><a href="#创建操作符" class="headerlink" title="创建操作符"></a>创建操作符</h1><p>下面的操作符用来创建 Observable，<a href="https://github.com/maintel/KotlinTest/blob/master/app/src/test/java/com/demo/kotlintest/RxJavaCreateTest.kt" target="_blank" rel="external">示例代码</a></p>
<h2 id="Create"><a href="#Create" class="headerlink" title="Create"></a><a href="http://reactivex.io/documentation/operators/create.html" target="_blank" rel="external">Create</a></h2><p>使用一个函数从头创建一个 Observable</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">    Observable.create(<span class="keyword">object</span> : ObservableOnSubscribe&lt;String&gt; &#123;</div><div class="line">        <span class="comment">// 常规写法</span></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">subscribe</span><span class="params">(e: <span class="type">ObservableEmitter</span>&lt;<span class="type">String</span>&gt;?)</span></span> &#123;</div><div class="line">            e?.onNext(<span class="string">"aaaa"</span>)</div><div class="line">            e?.onNext(<span class="string">"bbb"</span>)</div><div class="line">            e?.onNext(<span class="string">"ccc"</span>)</div><div class="line">            e?.onComplete()</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribe(<span class="keyword">object</span> : Observer&lt;String&gt; &#123;</div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onComplete</span><span class="params">()</span></span> &#123;</div><div class="line">            println(<span class="string">"完成"</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubscribe</span><span class="params">(d: <span class="type">Disposable</span>?)</span></span> &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onNext</span><span class="params">(value: <span class="type">String</span>?)</span></span> &#123;</div><div class="line">            println(value)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(e: <span class="type">Throwable</span>?)</span></span> &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 下面是 lambda 写法</span></div><div class="line"></div><div class="line">    Observable.create&lt;String&gt; &#123; e -&gt;</div><div class="line">        e.onNext(<span class="string">"a"</span>)</div><div class="line">        e.onNext(<span class="string">"b"</span>)</div><div class="line">        e.onComplete()</div><div class="line">    &#125;.subscribe &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
<p>create 操作符默认不在任何调度器上执行</p>
<h2 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a><a href="http://reactivex.io/documentation/operators/defer.html" target="_blank" rel="external">Defer</a></h2><p>只有当订阅者订阅时才创建 observable，并且为每个观察者创建新的 Observable，即使他们看起来是一样的</p>
<h2 id="Empty-Never-Throw"><a href="#Empty-Never-Throw" class="headerlink" title="Empty/Never/Throw"></a><a href="http://reactivex.io/documentation/operators/empty-never-throw.html" target="_blank" rel="external">Empty/Never/Throw</a></h2><ul>
<li><code>Empty</code><br>  创建一个不发射数据但正常终止的 Observable</li>
<li><code>Never</code><br>  创建一个不发射数据也不终止的 Observable</li>
<li><code>Throw</code><br>  创建一个不发射数据并以一个错误终止的 Observable</li>
</ul>
<h2 id="From"><a href="#From" class="headerlink" title="From"></a><a href="http://reactivex.io/documentation/operators/from.html" target="_blank" rel="external">From</a></h2><p>将其他种类的对象和数据类型转换成 Observable</p>
<p>在 RxJava 2 中有一下几种实现</p>
<ul>
<li><code>fromArray</code><br>  将一个数组的每一项发射出去</li>
<li><code>fromIterable</code><br>  将一个 Iterable 中的每一项发射出去</li>
<li><p><code>fromPublisher</code><br>  将任意的流转换成可观察的</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Observable.fromPublisher&lt;String&gt; &#123; s -&gt; s.onNext(<span class="string">"aaaa"</span>) &#125;</div><div class="line">        .subscribe &#123; value -&gt; println(value) &#125; <span class="comment">// 输出结果 aaaa</span></div></pre></td></tr></table></figure>
</li>
<li><p><code>fromFuture</code><br>  将 Future.get() 返回的数据发射出去</p>
</li>
<li><code>fromCallable</code><br>  将 Callable.call() 返回的数据发射出去</li>
</ul>
<h2 id="Interval"><a href="#Interval" class="headerlink" title="Interval"></a><a href="http://reactivex.io/documentation/operators/interval.html" target="_blank" rel="external">Interval</a></h2><p>创建一个在给定间隔时间发送整数数列的 Observable，注意这个默认实现除非手动停止否则<strong>不会停止</strong>。</p>
<h2 id="Just"><a href="#Just" class="headerlink" title="Just"></a><a href="http://reactivex.io/documentation/operators/just.html" target="_blank" rel="external">Just</a></h2><p>创建一个发射给定项目的 Observable，最多有10个参数，而且在 2.0 以后版本中不再支持发送 null。</p>
<h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a><a href="http://reactivex.io/documentation/operators/range.html" target="_blank" rel="external">Range</a></h2><p>这个操作符的默认实现是发送一个特定范围内递增的整数序列，范围为 n ~ n+m-1</p>
<p>还有另外一个实现</p>
<ul>
<li><code>intervalRange</code><br>  发送一个具有特定时间间隔并且特定范围的序列<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// 发送一个从1 到 100 首项延迟1秒 后面项间隔为2秒的序列</span></div><div class="line">Observable.intervalRange(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS)</div><div class="line">         .subscribe &#123; value -&gt; println(value) &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a><a href="http://reactivex.io/documentation/operators/repeat.html" target="_blank" rel="external">Repeat</a></h2><p>创建一个重复发射原始序列项的 Observable，在 2.0 上有一下三种实现</p>
<ul>
<li><code>repeat</code><br>  无限次重复</li>
<li><code>repeatUntil</code><br>  根据参数中的函数如果返回 true 则停止重复发送</li>
<li><code>repeatWhen</code><br>  根据指定的 observable 发送和结束来判断原始的 observable 是否重复发送或结束</li>
</ul>
<h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a><a href="http://reactivex.io/documentation/operators/timer.html" target="_blank" rel="external">Timer</a></h2><p>创建一个 Observable 在一定的延迟以后才发送消息</p>
<h1 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h1><p>下面的这些操作符可以对 observable 发射的数据做各种变换，<a href="https://github.com/maintel/KotlinTest/blob/master/app/src/test/java/com/demo/kotlintest/RxJavaTransformTest.kt" target="_blank" rel="external">示例代码</a></p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a><a href="http://reactivex.io/documentation/operators/buffer.html" target="_blank" rel="external">Buffer</a></h2><p>周期性的将原始 observable 发射的数据收集在一起然后发射出去。buffer 支持通过时间或者序列长度或者指定的 Observable 来建立不同大小缓冲区。</p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><a href="http://reactivex.io/documentation/operators/flatmap.html" target="_blank" rel="external">FlatMap</a></h2><p>将一个对原始 observable 发射的每一项数据执行变换操作，并且返回一个 observable，然后 flatMap 将每一项返回的 observables 合并（内部执行了 merge）的结果作为自己的数据序列发射。注意和下面的 map 的区别。flatMap 有以下：</p>
<ul>
<li><code>flatMap</code><br>  基础实现，不能保证合并以后的顺序，原因是内部执行了 merge，它还可以接受一个参数 int 设置 flatMap 原始 observable 到 observables 的最大同时订阅数，以及一个 Boolean 来确保当出现 onError 时不会终止。</li>
<li><code>concatMap</code><br>  和 flatMap 的区别就是保证了原始的顺序</li>
<li><code>flatMapIterable</code><br>  参数中的函数返回一个 list，flatMap 将这些 list 中的每一项作为一个消息单独发射出去。既是一个典型的一变多</li>
<li><code>concatMapIterable</code><br>  和 flatMap 一样，不同之处在于保证了消息的顺序</li>
<li><code>concatMapDelayError</code><br>  和 concatMap 一样，不同之处在于将变换的后的 Observable 出现的 onError 事件延迟到所有序列的最后</li>
<li><code>concatMapEager</code><br>  一旦有订阅，操作符就会订阅所有的原始 observable，它能够确保原始消息中的第一项首先执行，注意这个操作符在使用背压的时候才有效</li>
<li><code>concatMapEagerDelayError</code><br>  和 concatMapEager 一样，并保证了将 onError 延迟到最后再执行</li>
<li><code>switchMap</code><br>  当转换后的 observable 没有执行完时有新转换的 observable 出现，就会切换到新的 observable 上。</li>
<li><code>switchMapDelayError</code><br>  同上</li>
</ul>
<p><strong>注意：</strong> 如果任何一个通过这个 flatMap 操作产生的单独的 Observable 调用 onError 异常终止了，这个 Observable 自身会立即调用 onError 并终止，带有 DelayError 参数的除外</p>
<h2 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a><a href="http://reactivex.io/documentation/operators/groupby.html" target="_blank" rel="external">GroupBy</a></h2><p>将原始 Observable 的每一项按照特定条件分组，并放在子 Observable 中发射出去。接收者可以按照设定的 Key 来对不同的子 Observable 做订阅并处理</p>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><a href="http://reactivex.io/documentation/operators/map.html" target="_blank" rel="external">Map</a></h2><p>对原始的 Observable 的每一项做变换</p>
<ul>
<li><code>cast</code><br>  对每一项做一次强制类型转换</li>
</ul>
<h2 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a><a href="http://reactivex.io/documentation/operators/scan.html" target="_blank" rel="external">Scan</a></h2><p>函数中能够获取到序列中上一个被发射出去的项以及当前项，可以根据需要进行处理，并把结果发射出去</p>
<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a><a href="http://reactivex.io/documentation/operators/window.html" target="_blank" rel="external">Window</a></h2><p>将源 Observable 的序列按照长度或者时间或者另外一个指定的 Observable 等进行分组，和 Buffer 有点像，不同之处在于 Window 最后发射出去的是一个 observable 序列，Buffer 发射的是一个 List</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>以上就是 Observable 的创建以及变换操作符，这里也只是做了大致的说明因为有很多操作符有很多重载，比如 buffer 和 window 等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;从前年开始使用 RxJava，后来换了工作以后虽然项目中一样使用了 RxJava 但是工作的侧重点更多的转向了前端上面，现在重新回到源生上再
    
    </summary>
    
      <category term="开源" scheme="https://maintel.github.io/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="RxJava" scheme="https://maintel.github.io/tags/RxJava/"/>
    
      <category term="操作符" scheme="https://maintel.github.io/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号开发进行本地调试的方法</title>
    <link href="https://maintel.github.io//blog/2017/09/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91%E8%BF%9B%E8%A1%8C%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>https://maintel.github.io//blog/2017/09/微信公众号开发进行本地调试的方法.html</id>
    <published>2017-09-20T14:22:14.000Z</published>
    <updated>2018-03-14T14:26:53.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>由于微信的一些我们看来很蛋疼的规定，在微信公众号开发以及调用 JSSDK 时域名限制比较严格，在进行开发的时候调试起来很是麻烦，之前开发的时候很多时候就是打包–发布测试–修改–再打包。。。这样来循环调试，费时费力。现在想一劳永逸的解决这个问题。</p>
<p>查了一些资料发现很多的方法就是通过内网穿透，使用花生壳或者 Ngrok 来达到内网穿透的目的，再在微信后台配置给定的域名，最终实现对域名的代理。</p>
<p>关于 ngrok 的使用方法看<a href="https://www.sunnyos.com/article-show-67.html" target="_blank" rel="external">这里</a>,不过最终我没有选择这个方案，因为这种方式要到后台去配置域名，而且微信对域名的配置是有限制的。然后就选用了下面的方法，即通过修改本地 host 以及代理的方式去实现，成本更小。</p>
<h1 id="mac-修改-host"><a href="#mac-修改-host" class="headerlink" title="mac 修改 host"></a>mac 修改 host</h1><p>修改 host 还是比较简单的，<code>vim /etc/hosts/</code>然后修改自己想要的就可以了。但是在开发中改来改去这样子还是显得麻烦，所以还是借助工具来比较简单，这里借助 Gas Mask 来实现一键切换 host。<a href="https://github.com/2ndalpha/gasmask" target="_blank" rel="external">下载地址</a></p>
<p><img src="http://blogqn.maintel.cn/QQ20180306-154434@2x.png?e=3097122322&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:UUes2QtiP9HnEdH76jO0WFrAPmA=" alt="gas mask"></p>
<h1 id="配置-webpack"><a href="#配置-webpack" class="headerlink" title="配置 webpack"></a>配置 webpack</h1><p>这里是调试的 react 项目，使用 webpack 作为打包测试工具。</p>
<p>配置成功以后输入<code>test.xxxx.com:8005/xxxx</code>来访问调试服务器，竟然出现空白页面，并且报<code>invalid host header</code>错误。经过一番查询发现是 host 检查的错误。</p>
<p>可以对 devServer 作如下几种配置</p>
<ul>
<li><p>禁止 host 检查</p>
<p><code>disableHostCheck: true</code></p>
</li>
<li><p>设置公共 Host</p>
<p><code>public: &#39;exampleHost.com&#39;</code></p>
</li>
<li><p>设置被允许 host 列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">allowedHosts: [</div><div class="line">      &apos;exampleHost.com&apos;,</div><div class="line">      &apos;differentExampleHost.com&apos;,</div><div class="line">      ...</div><div class="line">]</div></pre></td></tr></table></figure>
<p>配置完成以后重启服务，终于可以在微信调试工具中正常的访问，并且成功调起 JSSDK。</p>
<h1 id="在手机上访问服务"><a href="#在手机上访问服务" class="headerlink" title="在手机上访问服务"></a>在手机上访问服务</h1><p>上面成功是实现了本地代理，但是如果如果可以在微信中打开调试的链接，直接在手机上面调试 JSSDK 里面的功能岂不是更好。</p>
<p>当然也有办法实现——通过 charles，实现方式也很简单。</p>
<p>charles 的下载地址在<a href="https://www.charlesproxy.com/download/" target="_blank" rel="external">这里</a>，至于怎么用手机连接代理这里就不在介绍，只介绍怎么设置远程代理。</p>
<p>点击 tools – Map Remote。</p>
<p><img src="http://blogqn.maintel.cn/QQ20180306-162202@2x.png?e=3097124630&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:XwdPGTdEzWq9SJSVHKbj5s7QhSk=" alt="远程代理1"></p>
<p>然后启用，添加一个代理。</p>
<p> <img src="http://blogqn.maintel.cn/QQ20180306-162328@2x.png?e=3097124630&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:lUDVGpCsQg1Q6K6ibInYuugzwsc=" alt="远程代理1"></p>
<p> 完成以后，手机连上代理就可以在微信中打开调试的页面实时的调试效果了。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;由于微信的一些我们看来很蛋疼的规定，在微信公众号开发以及调用 JSSDK 时域名限制比较严格，在进行开发的时候调试起来很是麻烦，之前开发的时
    
    </summary>
    
      <category term="前端" scheme="https://maintel.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="公众号开发" scheme="https://maintel.github.io/tags/%E5%85%AC%E4%BC%97%E5%8F%B7%E5%BC%80%E5%8F%91/"/>
    
      <category term="JSSDK" scheme="https://maintel.github.io/tags/JSSDK/"/>
    
  </entry>
  
  <entry>
    <title>使用动态路由优化H5加载速度</title>
    <link href="https://maintel.github.io//blog/2017/09/%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BC%98%E5%8C%96%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6.html"/>
    <id>https://maintel.github.io//blog/2017/09/使用动态路由优化加载速度.html</id>
    <published>2017-09-17T14:34:31.000Z</published>
    <updated>2018-03-18T03:39:45.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前的 APP 已经差不多有70%的业务使用 H5 来实现，但是一些页面的白屏现象严重。之前分别从<a href="http://blog.maintel.cn/blog/2017/09/%E5%8E%9F%E7%94%9F%E7%9B%91%E6%8E%A7WebView%E5%8A%A0%E8%BD%BDHtml%E7%9A%84%E8%BF%87%E7%A8%8B-md.html" target="_blank" rel="external">原生层面</a>对 WebView 加载 HTML 以及 H5 层面的 <a href="http://blog.maintel.cn/blog/2017/09/window-performance%E5%88%86%E6%9E%90Html%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html" target="_blank" rel="external">HTML 的加载过程</a>进行了分析，确定出加载的耗时主要出现在渲染阶段，但是页面本身并不复杂，dom 的结构也很简单，应该渲染很快才对，所以又通过 chrome 的 timeline 来进行更详细分析的<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/" target="_blank" rel="external">开发文档</a>，结果如下图，可以确定出在一次加载过程中主要的耗时在 JS 的运算上面。</p>
<p><img src="http://blogqn.maintel.cn/QQ20180305-175335@2x.png?e=3097043637&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:OLB8NxtvoFFxegzb60x69sStyAQ=" alt="js 加载耗时"></p>
<p>由此可以引发出一些思考，因为用来做分析的页面本身很简单，没有很多的 js 运算才对。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>经过一系列的监控发现加载过程的主要耗时在 js 的运算上面，目标页面并不复杂，仅仅是加载了一个列表而已，没有大量的业务需要进行 js 运算，那这些 js 都是哪来的？又查看了加载以后的 js 竟然有接近 2M，这显然是不正常的，原因出在哪？答案就在 react 项目的打包上，虽然我们的项目已经使用了多页面，但是实际上并不能叫多页面，更准确的应该叫多模块才对，一个模块的所有页面全部在一个总的路由下面，即在一个 html 中，同一模块下的所有页面使用一个 js，而即使通过路由加载一个很简单的页面也有把所有的这些 js 全部加载进来，这些势必造成了长时间的运算。</p>
<p>问题找到了，经过查阅资料发现比较好的解决办法就是使用动态路由。</p>
<h1 id="现有路由"><a href="#现有路由" class="headerlink" title="现有路由"></a>现有路由</h1><p>现在林林总总路由加起来有二十多个。经过打包以后的js大小有2M多。这就势必拖慢了加载的速度，在不考虑优化 js 逻辑相关的代码前，使用动态路由技术来对代码进行分离，做到按需加载应该能够提高加载速度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> &lt;Route path=<span class="string">"/"</span> component=&#123;WaterIndex&#125; /&gt;</div><div class="line">  &lt;Route path="/AddWaterMeter" component=&#123;AddWaterMeter&#125; /&gt;</div><div class="line">  &lt;Route path="/ConfirmMeter" component=&#123;ConfirmMeter&#125; /&gt;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  &lt;Route path="/FeedbackList" component=&#123;FeedbackList&#125; /&gt;</div><div class="line">  &lt;Route path="/PaymentHelp" component=&#123;PaymentHelp&#125; /&gt;</div><div class="line">&lt;/Router&gt;</div></pre></td></tr></table></figure>
<h1 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h1><p>原理就是将当前的代码在打包过程中分拆成多个小的包，在用户浏览过程中进行按需加载。<a href="https://react-guide.github.io/react-router-cn/docs/guides/advanced/DynamicRouting.html" target="_blank" rel="external">示例代码</a></p>
<h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><p>首先在 webpack.config.js 的 output 内加上 chunkFilename</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">output: &#123;</div><div class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">'/../dist/assets'</span>),</div><div class="line">    <span class="attr">filename</span>: <span class="string">'app.js'</span>,</div><div class="line">    <span class="attr">publicPath</span>: defaultSettings.publicPath,</div><div class="line">    <span class="comment">// 添加 chunkFilename</span></div><div class="line">    chunkFilename: <span class="string">'[name].[chunkhash:5].chunk.js'</span>,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>name 是在代码里为创建的 chunk 指定的名字，如果代码中没指定则 webpack 默认分配 id 作为 name。chunkhash 是文件的 hash 码，这里只使用前五位。</p>
<h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>之前的路由就像上面配置的一样，现在修改成如下的样子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> AddWaterMeter = <span class="function">(<span class="params">location, callback</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</div><div class="line">    callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./views/AddWaterMeter'</span>).default)</div><div class="line">  &#125;, <span class="string">'AddWaterMeter'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> WaterMeterList = <span class="function">(<span class="params">location, callback</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</div><div class="line">    callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./views/WaterMeterList'</span>).default)</div><div class="line">  &#125;, <span class="string">'WaterMeterList'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ConfirmMeter = <span class="function">(<span class="params">location, callback</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">require</span>.ensure([], <span class="built_in">require</span> =&gt; &#123;</div><div class="line">    callback(<span class="literal">null</span>, <span class="built_in">require</span>(<span class="string">'./views/ConfirmMeter'</span>).default)</div><div class="line">  &#125;, <span class="string">'ConfirmMeter'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;Router</div><div class="line">    history=&#123;hashHistory&#125;</div><div class="line">    render=&#123;applyRouterMiddleware(useScroll())&#125;</div><div class="line">  &gt;</div><div class="line">    &lt;Route path="/" Component=&#123;WaterIndex&#125;&gt;</div><div class="line">      &lt;Route path="AddWaterMeter" Component=&#123;AddWaterMeter&#125; /&gt;</div><div class="line">      &lt;Route path="ConfirmMeter" getComponent=&#123;ConfirmMeter&#125; /&gt;</div><div class="line">      &lt;Route path="WaterMeterList" getComponent=&#123;WaterMeterList&#125; /&gt;</div><div class="line"></div><div class="line">      ...</div><div class="line"></div><div class="line">      &lt;Route path="FeedbackList" getComponent=&#123;FeedbackList&#125; /&gt;</div><div class="line">      &lt;Route path="PaymentHelp" getComponent=&#123;PaymentHelp&#125; /&gt;</div><div class="line">    &lt;/Route&gt;</div><div class="line">  &lt;/Router&gt;,</div><div class="line">  document.getElementById('app')</div><div class="line">)</div></pre></td></tr></table></figure>
<p>history 不变，将创建的路由传递进去。有几个属性的说明</p>
<ul>
<li><p>path</p>
<p>匹配路由，和之前的定义一样</p>
</li>
<li><p>getComponent</p>
<p>对应于以前的 component 属性，但是这个方法是异步的，也就是当路由匹配时，才会调用这个方法。</p>
<p>这里面有个 require.ensure 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>.ensure(dependencies, callback, chunkName)</div></pre></td></tr></table></figure>
<p>这是 webpack 提供的方法，这也是按需加载的核心方法。第一个参数是依赖，第二个是回调函数，第三个就是上面提到的 chunkName，用来指定这个 chunk file 的 name。</p>
</li>
</ul>
<p>这里有可能会有一个异常:</p>
<p><strong>The root route must render a single element</strong></p>
<p>这是因为 module.exports 和 ES6 里的 export default 有区别。</p>
<p>如果是使用 es6 的写法，也就是你的组件都是通过 export default 导出的，那么在 getComponent 方法里面需要加入 .default。<br>如果是使用 CommonJS 的写法，也就是通过 module.exports 导出的，那就无须加 .default 了。</p>
<h1 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h1><p>经过上面的一通操作，再来看一下页面的加载速度，首先是可以明显的感知到速度变快。通过 timeline 来检测一下</p>
<p><img src="http://blogqn.maintel.cn/QQ20180305-0.jpg?e=3097049055&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:UamaCXTNkmvDLHeA9s6gn7wg8Js=" alt="优化结果"></p>
<p>可以看到，速度提升了1s，对产品体验来说是一个很大的提升。</p>
<p><em>参考资料</em></p>
<p><a href="https://segmentfault.com/a/1190000011765141" target="_blank" rel="external">React-Router动态路由设计最佳实践</a><br><a href="https://segmentfault.com/a/1190000007141049" target="_blank" rel="external">react-router 按需加载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前的 APP 已经差不多有70%的业务使用 H5 来实现，但是一些页面的白屏现象严重。之前分别从&lt;a href=&quot;http://blog.
    
    </summary>
    
      <category term="前端" scheme="https://maintel.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react" scheme="https://maintel.github.io/tags/react/"/>
    
      <category term="动态路由" scheme="https://maintel.github.io/tags/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    
      <category term="H5优化" scheme="https://maintel.github.io/tags/H5%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>原生监控WebView加载Html的过程</title>
    <link href="https://maintel.github.io//blog/2017/09/%E5%8E%9F%E7%94%9F%E7%9B%91%E6%8E%A7WebView%E5%8A%A0%E8%BD%BDHtml%E7%9A%84%E8%BF%87%E7%A8%8B-md.html"/>
    <id>https://maintel.github.io//blog/2017/09/原生监控WebView加载Html的过程-md.html</id>
    <published>2017-09-13T15:04:11.000Z</published>
    <updated>2018-03-18T03:27:45.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监控加载过程"><a href="#监控加载过程" class="headerlink" title="监控加载过程"></a>监控加载过程</h1><blockquote>
<p>获取 webView 加载过程中的各个阶段的耗时情况</p>
</blockquote>
<p>由于页面打开的过程中白屏情况严重，要解决问题，首先要分析问题出在哪。</p>
<h2 id="从源生层面分析"><a href="#从源生层面分析" class="headerlink" title="从源生层面分析"></a>从源生层面分析</h2><p>分别在加载 webView 的 activity 的 onCreate 、onResume 方法中记录时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LogUtils.e(<span class="string">"onResume::"</span> + System.currentTimeMillis());</div></pre></td></tr></table></figure>
<p>对 webView 设置自定义 WebViewClient,并记录 html 的加载时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">webView.setWebViewClient(<span class="keyword">new</span> MyWebViewClient());</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebViewClient</span> <span class="keyword">extends</span> <span class="title">WebViewClient</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageFinished</span><span class="params">(WebView view, String url)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPageFinished(view, url);</div><div class="line">        LogUtils.e(<span class="string">"onPageFinished::"</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageStarted</span><span class="params">(WebView webView, String s, Bitmap bitmap)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPageStarted(webView, s, bitmap);</div><div class="line">        LogUtils.e(<span class="string">"onPageStarted::"</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>原生监控结果</strong></p>
<blockquote>
<p>E/tag: onCreate::1519980761086</p>
<p>E/tag: onResume::1519980761202</p>
<p>E/tag: onPageStarted::1519980761246</p>
<p>E/tag: onPageFinished::1519980762874</p>
<p>…</p>
</blockquote>
<p>可以看到主要耗时是在 Html 的加载过程中。</p>
<h2 id="从-H5-端进行监控"><a href="#从-H5-端进行监控" class="headerlink" title="从 H5 端进行监控"></a>从 H5 端进行监控</h2><p>这里主要是通过 performance.timing 来分析 H5 加载过程中各个节点的耗时情况</p>
<p>有两个方法</p>
<h3 id="通过源生代码"><a href="#通过源生代码" class="headerlink" title="通过源生代码"></a>通过源生代码</h3><p>增加以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webView.setWebChromeClient(<span class="keyword">new</span> WebChromeClient());</div></pre></td></tr></table></figure>
<p>然后在 WebViewClient.onPageFinished 结束后，延迟几秒钟执行 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webview.loadUrl(<span class="string">"javascript:alert(JSON.stringify(window.performance.timing))"</span>);</div></pre></td></tr></table></figure>
<p>这样就可以看到各个节点的耗时，但是这样不便于记录和观察，可以通过一个写一个 js 方法来把数据获取过来进行输出。</p>
<p>不过一般采用第二种方法比较方便。</p>
<h3 id="通过-chrome-浏览器的调试功能"><a href="#通过-chrome-浏览器的调试功能" class="headerlink" title="通过 chrome 浏览器的调试功能"></a>通过 chrome 浏览器的调试功能</h3><p><strong>注意：</strong> Android 的版本要在 4.0 以上</p>
<p>在 chrome 中输入 chrome://inspect 如下：</p>
<p><img src="http://blogqn.maintel.cn/QQ20180302-170347@2x.png?e=3096781460&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:hdfqLl0D8y77urO_I44XYU1E2mg=" alt="chromeinspect"></p>
<p>然后点击 inspect，在控制台输入window.performance</p>
<p><img src="http://blogqn.maintel.cn/QQ20180302-170814@2x.png?e=3096781717&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:MyWvKHEazHhT6u3GzIT95kaLViI=" alt="performance"></p>
<hr>
<p>各参数的解读可以参考<a href="./window-performance分析Html加载过程.html">这里</a></p>
<p>然后就可以通过上面拿到的内容分析出具体是哪里太过耗时然后针对性的进行优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;监控加载过程&quot;&gt;&lt;a href=&quot;#监控加载过程&quot; class=&quot;headerlink&quot; title=&quot;监控加载过程&quot;&gt;&lt;/a&gt;监控加载过程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;获取 webView 加载过程中的各个阶段的耗时情况&lt;/p&gt;
&lt;/blockquo
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="webView" scheme="https://maintel.github.io/tags/webView/"/>
    
  </entry>
  
  <entry>
    <title>window.performance分析Html加载过程</title>
    <link href="https://maintel.github.io//blog/2017/09/window-performance%E5%88%86%E6%9E%90Html%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.html"/>
    <id>https://maintel.github.io//blog/2017/09/window-performance分析Html加载过程.html</id>
    <published>2017-09-13T14:58:28.000Z</published>
    <updated>2018-03-13T15:13:48.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="window-performance-分析-Html-加载过程"><a href="#window-performance-分析-Html-加载过程" class="headerlink" title="window.performance 分析 Html 加载过程"></a>window.performance 分析 Html 加载过程</h1><p>window.performance是HTML5 的一个新API。<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/performance" target="_blank" rel="external">详细文档</a></p>
<h2 id="浏览器一般加载顺序"><a href="#浏览器一般加载顺序" class="headerlink" title="浏览器一般加载顺序"></a>浏览器一般加载顺序</h2><p>如下图：</p>
<p><img src="http://blogqn.maintel.cn/011624558421157.png?e=3096780128&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:3ErJgje_bBt1umNYY6w5UUKVSgM=" alt="浏览器加载顺序"></p>
<h2 id="字段含义"><a href="#字段含义" class="headerlink" title="字段含义"></a>字段含义</h2><ul>
<li><p>navigationStart</p>
<p>当访问一个新页面时，当前页面卸载完成所返回的时间点，如果没有当前页面，则返回 fetchStart 时间点。</p>
</li>
<li><p>redirectStart</p>
<p>如果是HTTP重定向，如果跳转都是同源的，则返回开始获取发起重定向的时间点，否则返回0</p>
</li>
<li><p>redirectEnd</p>
<p>如果是同源重定向，返回重定向请求接收完最后一字节的时间点，否则返回0</p>
</li>
<li><p>fetchStart</p>
<p>如果请求是用http get发起的，返回浏览器查缓存之前的时间点，否则返回发起获取资源的时间点</p>
</li>
<li><p>domainLookupStart</p>
<p>返回浏览器发起DNS查询的时间点，如果是长连接或者请求文件来自缓存等本地存储则返回fetchStart时间点</p>
</li>
<li><p>domainLookupEnd</p>
<p>返回结束DNS查询的时间点，如果是长连接或者请求文件来自缓存等本地存储则返回fetchStart时间点</p>
</li>
<li><p>connectStart</p>
<p>返回浏览器向服务器发起建立获取当前文档的连接请求的时间点，如果是长连接或者请求文件来自缓存等本地存储则返回domainLookupEnd时间点</p>
</li>
<li><p>connectEnd</p>
<p>返回与服务器建立完成连接的时间点，如果是长连接或者请求文件来自缓存等本地存储则返回domainLookupEnd时间点</p>
</li>
<li><p>requestStart</p>
<p>返回浏览器发起请求的时间，不管是向server还是本地缓存或存储</p>
</li>
<li><p>responseStart</p>
<p>返回浏览器拿到第一个响应字节的时间点，包括从服务器、缓存或者其他本地存储</p>
</li>
<li><p>responseEnd</p>
<p>返回浏览器拿到最后一个响应字节或者传输连接关闭的时间点，包括从服务器、缓存或者其他本地存储</p>
</li>
<li><p>unloadEventStart</p>
<p>为 unload 事件被触发之时的 Unix毫秒时间戳。如果没有上一个文档，或者上一个文档或需要重定向的页面之一不同源，则该值返回 0。</p>
</li>
<li><p>unloadEventEnd</p>
<p>如果要打开的页面和当前的页面同源，则返回用户unload事件执行完成后的时间点，如果当前文档不存在或者不同源，则返回0</p>
</li>
<li><p>domLoading</p>
<p>返回浏览器将当前文档状态设置成loading的时间点</p>
</li>
<li><p>domInteractive</p>
<p>返回浏览器将当前文档状态设置成interactive的时间点</p>
</li>
<li><p>domContentLoadedEventStart</p>
<p>返回浏览器触发DOMContentLoaded事件执行之前的时间点</p>
</li>
<li><p>domContentLoadedEventEnd</p>
<p>返回浏览器触发DOMContentLoaded事件执行完成的时间点</p>
</li>
<li><p>domComplete</p>
<p>返回浏览器将当前文档状态设置成complete的时间点</p>
</li>
<li><p>loadEventStart</p>
<p>返回浏览器触发load事件执行之前的时间点，否则为0</p>
</li>
<li><p>loadEventEnd</p>
<p>返回浏览器触发load事件执行完成的时间点</p>
</li>
</ul>
<p>然后就可以根据各个节点的时间来计算出各个阶段的耗时，比如渲染阶段为 domComplete - domLoading</p>
<hr>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/joyho/articles/4384306.html" target="_blank" rel="external">使用window.performance对应用性能监测</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;window-performance-分析-Html-加载过程&quot;&gt;&lt;a href=&quot;#window-performance-分析-Html-加载过程&quot; class=&quot;headerlink&quot; title=&quot;window.performance 分析 Html 加载过
    
    </summary>
    
      <category term="前端" scheme="https://maintel.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="html优化" scheme="https://maintel.github.io/tags/html%E4%BC%98%E5%8C%96/"/>
    
      <category term="html加载" scheme="https://maintel.github.io/tags/html%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>[Spring] 装配 bean</title>
    <link href="https://maintel.github.io//blog/2017/05/spring2bean.html"/>
    <id>https://maintel.github.io//blog/2017/05/spring2bean.html</id>
    <published>2017-05-09T10:01:19.000Z</published>
    <updated>2018-03-13T14:46:37.034Z</updated>
    
    <content type="html"><![CDATA[<p>任何一个应用都是由多了为了实现业务目标而相互协作的对象构成，传统的方法中创建这些对象间的关联关系通常通过构造器或者查找，而这通常会导致高度耦合、结构复杂、难以复用以及难以进行单元测试。</p>
<p>在 Spring 中，对象无需自己查找或者创建与其关联的其他对象，容器负责把需要相互协作的对象引用赋予各个对象。创建对象之间的协作关系行为称为<strong>装配</strong>，这也是依赖注入（DI）的本质。</p>
<a id="more"></a>
<h1 id="Spring-装配-bean"><a href="#Spring-装配-bean" class="headerlink" title="Spring 装配 bean"></a>Spring 装配 bean</h1><p>Spring 提供了三种装配机制：</p>
<ul>
<li>在 XML 中进行显式配置；</li>
<li>在 Java 中进行显式配置；</li>
<li>隐式的 Bean 发现机制和自动装配。</li>
</ul>
<p>这三种方式可以互相搭配，而且没有说明某个场景下一定要选用哪种机制。</p>
<h2 id="自动化装配-Bean"><a href="#自动化装配-Bean" class="headerlink" title="自动化装配 Bean"></a>自动化装配 Bean</h2><p>自动化装配是最便利的配置方案。需要从两个角度来实现：</p>
<ul>
<li>组件自动扫描（component scanning）：Spring 会自动发现应用中上下文创建的 bean；</li>
<li>自动组装（autowiring）：Spring 自动满足 bean 间的依赖。</li>
</ul>
<p>（哦 就是 @component 和 @Autowired 嘛）</p>
<p>但是在使用的时候需要显式的配置 Spring，好让其去主动寻找带有 @component 注解的类，并创建 bean。有两种方式指定：</p>
<p>方式一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@ComponentScan</span>  <span class="comment">//启用组件扫描。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@componentScan 默认会扫描当前包下及所有子包，自动查找带有 @component 注解的类。</p>
<p>方式二：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-pakage</span>=<span class="string">"packageName"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>component-scan 和 @ComponentScan 注解有相同的属性，有以下两个重要的属性：</p>
<ul>
<li><p>basePackage </p>
<p>  指定一个或者多个包名。</p>
</li>
<li><p>basePackageClasses</p>
<p>  指定扫描的类或者实现了某个接口的类。</p>
</li>
</ul>
<p><strong>@Autowired</strong> 注解可以实现自动装配，就是在 Spring 在创建一个 bean 的时候，会根据它来实现自动加入此 bean 所需要的依赖。</p>
<p>比如下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"go go go!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span>   <span class="comment">//通过注解自动注入</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</div><div class="line">        engine.power();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Configuration</span>  <span class="comment">//表明这是一个配置类</span></div><div class="line"><span class="meta">@ComponentScan</span>  <span class="comment">//配置扫描</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 在一个测试类中进行测试。</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BeanFactory factory = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class); <span class="comment">//解析配置类</span></div><div class="line">        Car car = factory.getBean(Car.class);</div><div class="line">        car.go();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 运行Test 类可以看到输出 go go go!</span></div></pre></td></tr></table></figure>
<p>@Autowired 注解可以有多种用法，可以用在构造函数中，或者一个方法上。同时可以使用 java 原生的 @Inject 注解来代替它，在大多数情况下是没有任何问题的。</p>
<p>大多数时候使用自动化配置来装配 bean，但是有时候这种方法行不通，比如引用一个第三方库的类时，没法给它添加注解，这个时候就需要用到下面两个方法。</p>
<h2 id="通过-Java-装配-bean"><a href="#通过-Java-装配-bean" class="headerlink" title="通过 Java 装配 bean"></a>通过 Java 装配 bean</h2><p>通过 Java 来装配 bean 很简单，主要是借助 JavaConfig 来实现注入。有两个注解</p>
<ul>
<li>Configuration 声明一个配置类</li>
<li>@Bean 创建一个 bean 实例</li>
</ul>
<p>改造上面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Engine 和 Car 不带有任何注解的普通 java 类</span></div><div class="line"><span class="comment">// 配置类</span></div><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(getEngine()); </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar2</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(getEngine());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="comment">// 测试</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        BeanFactory beanFactory = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</div><div class="line">        Car car = (Car) beanFactory.getBean(<span class="string">"getCar"</span>);  <span class="comment">// 获取方法就是根据方法名，除非显式的指定了 @Bean 的 name 属性</span></div><div class="line">        car.go();</div><div class="line">        System.out.println(car.getEngine());</div><div class="line">        Car car2 = (Car) beanFactory.getBean(<span class="string">"getCar2"</span>);</div><div class="line">        car2.go();</div><div class="line">        System.out.println(car2.getEngine());</div><div class="line">    &#125;</div><div class="line"><span class="comment">// 通过输出可以看到 car 和 car2 中的 engine 对象是同一个。</span></div></pre></td></tr></table></figure>
<p>上面方法中写了一个<code>new Car(getEngine())</code>,似乎每次执行都会new 一个新的 engine 实例，但事实并非如此，因为如果一个方法带有 @bean 注解，在默认情况下 Spring 会拦截所有对它的调用，并确保返回该方法创建的 bean，而不是每次都对其进行实际调用。另外需要说明的是，可以在带有 @Bean 注解的方法中做任何 Java 允许做的事情。</p>
<h2 id="使用-XML-来装配-bean"><a href="#使用-XML-来装配-bean" class="headerlink" title="使用 XML 来装配 bean"></a>使用 XML 来装配 bean</h2><p>通过 xml 来配置的方式在 Spring 历史中已经存在了很长时间，同时使用起来也比较复杂。具体使用可以用下面一图来表示。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170901164502.png?e=3081054847&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:WfKEQPLL18PbQw2U39GNAuz1Yus=" alt=""></p>
<p>以上是装配 Bean 的三种方式，这三种方式并不是只能独立的使用，它们之间可以相互混用，从而达到最佳方案。</p>
<h1 id="高级装配"><a href="#高级装配" class="headerlink" title="高级装配"></a>高级装配</h1><p>上面讲了 Spring 装配 bean 基本方法，Spring 还提供了很多高级的用法。</p>
<h2 id="配置-profile-bean"><a href="#配置-profile-bean" class="headerlink" title="配置 profile bean"></a>配置 profile bean</h2><p>最常见的情况是，开发过程中连接数据库在不同阶段使用的链接不同，开发环境，测试环境，生产环境等等。通过 profile 的配置可以灵活的切换他们而不引起问题。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">//开发环境</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">devDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Profile</span>(<span class="string">"test"</span>) <span class="comment">//测试环境</span></div><div class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">testDataSource</span><span class="params">()</span></span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//同样也可以通过 xml 来配置 &lt;bean profile="dev"&gt;...&lt;/bean&gt;</span></div></pre></td></tr></table></figure>
<p>然后就是如何激活 profile 了，当 profile 处于激活状态时才会创建这个 bean，如果没有都没有处于激活状态的话，则都不会创建。profile 的激活主要依赖于两个属性：</p>
<ul>
<li>spring.profiles.active</li>
<li>spring.profiles.default</li>
</ul>
<p>这两个属性相互独立，active 用来确定哪个 profile 会被激活，default 确定默认值。Spring 提供了多种方式来配置这两种属性：</p>
<ul>
<li>作为 DispatcherServlet 的初始化参数；</li>
<li>作为 Web 应用的上下文参数；</li>
<li>作为 JNDI 条目；</li>
<li>作为环境变量；</li>
<li>作为 JVM 的系统属性；</li>
<li>在集成测试类上，使用 @ActiveProlfiles 注解设置。</li>
</ul>
<h2 id="条件化-bean"><a href="#条件化-bean" class="headerlink" title="条件化 bean"></a>条件化 bean</h2><p>使用 @Conditional 注解可以约束只有当一个 bean 满足了特定的条件后才能被创建。注意：只有 Spring 4 以后才提供此注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Bean</span></div><div class="line">    <span class="meta">@Conditional</span>(ConditionalTest.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(getEngine());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionalTest</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</div><div class="line">        <span class="comment">//something</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如上面所示，@Conditional 注解必须给定一个实现了 Condition 接口的类，这个接口的实现很简单，通过 matches 方法返回值来确定是否创建 bean，true 则创建，false 则不创建。matches 方法给定的两个参数能够帮我们做很多事情，例如检查 bean 的定义、检查 bean 是否存在、检查某个资源是否加载、检查类的加载情况、检查是否有其他约束等。</p>
<p>而且从 Spring 4开始 @Profile 也是通过 @Conditional 注解来实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;任何一个应用都是由多了为了实现业务目标而相互协作的对象构成，传统的方法中创建这些对象间的关联关系通常通过构造器或者查找，而这通常会导致高度耦合、结构复杂、难以复用以及难以进行单元测试。&lt;/p&gt;
&lt;p&gt;在 Spring 中，对象无需自己查找或者创建与其关联的其他对象，容器负责把需要相互协作的对象引用赋予各个对象。创建对象之间的协作关系行为称为&lt;strong&gt;装配&lt;/strong&gt;，这也是依赖注入（DI）的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maintel.github.io/categories/Spring/"/>
    
    
      <category term="spring" scheme="https://maintel.github.io/tags/spring/"/>
    
      <category term="spring boot" scheme="https://maintel.github.io/tags/spring-boot/"/>
    
      <category term="java后台" scheme="https://maintel.github.io/tags/java%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>[Spring] 概述</title>
    <link href="https://maintel.github.io//blog/2017/05/spring1%E6%A6%82%E8%BF%B0.html"/>
    <id>https://maintel.github.io//blog/2017/05/spring1概述.html</id>
    <published>2017-05-07T09:54:23.000Z</published>
    <updated>2018-03-13T14:46:37.033Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉已经捣鼓了小半年的 Java 了，主要一直在使用 Spring boot 来开发，但是由于 Spring boot 使用起来太过简单了，虽然做了这么久但是对 Spring 框架、工作原理等还是一头雾水，很多东西不理解也不知道，所以决定从头开始看 Spring，从最基础最简单的 Spring 开始学习。本篇先来从概念的层面了解一下 Spring。</p>
<a id="more"></a>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>Spring Framework 是一个提供完善的基础设施用来支持来开发 Java 应用程序的 Java 平台。Spring 负责基础设施功能，使程序员可以专注于应用的开发。</p>
<p>简单的来说 Spring 是一个轻量级的 Java 开发框架。通过启用基于 POJO 编程模型来促进良好的编程实践。</p>
<p>Spring 为了减轻 Java 开发的复杂性，采用一下四种核心策略：</p>
<ul>
<li>基于 POJO 的轻量级和最小侵入式编程；</li>
<li>通过依赖注入和面向接口编程实现松耦合；</li>
<li>基于切面和惯例进行声明式编程；</li>
<li>通过切面和模板减少样板式代码。</li>
</ul>
<p>使用 Spring 的好处：</p>
<ul>
<li>使 Java 方法可以执行数据库事务而不用去处理事务 API。</li>
<li>使本地 Java 方法可以执行远程过程而不用去处理远程 API。</li>
<li>使本地 Java 方法可以拥有管理操作而不用去处理 JMX API。</li>
<li>使本地 Java 方法可以执行消息处理而不用去处理 JMS API。</li>
</ul>
<h1 id="Spring-核心功能"><a href="#Spring-核心功能" class="headerlink" title="Spring 核心功能"></a>Spring 核心功能</h1><p>Spring 的核心功能有两个</p>
<ul>
<li>Spring容器作为超级大工厂，负责创建、管理所有的Java对象，这些Java对象被称为Bean。</li>
<li>Spring容器管理容器中Bean之间的依赖关系，Spring使用一种被称为”依赖注入”的方式来管理Bean之间的依赖关系。</li>
</ul>
<h1 id="Spring-核心特性"><a href="#Spring-核心特性" class="headerlink" title="Spring 核心特性"></a>Spring 核心特性</h1><ul>
<li>依赖注入（DI）</li>
<li>面向切面编程（AOP）</li>
</ul>
<h1 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h1><p>POJO 是 Plain Old Java Object 的简称，POJO 和 JavaBean、EJB 一样是 Java 编程规范中的一种规范，并不是指一个特定的对象或者什么。POJO 的最原始的出处是《POJOs in Action》里面：</p>
<blockquote>
<p>The term was coined while Rebecca Parsons, Josh MacKenzie and I were preparing for a talk at a conference in September 2000. In the talk we were pointing out the many benefits of encoding business logic into regular java objects rather than using Entity Beans. We wondered why people were so against using regular objects in their systems and concluded that it was because simple objects lacked a fancy name. So we gave them one, and it’s caught on very nicely.</p>
</blockquote>
<p>大概的意思就是要将业务逻辑编码为常规java对象而不是使用实体Bean，并给这个常规的 Java 对象起了一个名字——POJO。</p>
<p>一个 POJO 应该是一个正规的 Java 对象，不但当任何特殊角色，也不实现任何 Java 框架指定的接口。它可以包含一些业务处理或持久化逻辑等。</p>
<p>Spring 的强大之处就是非侵入式的使用 POJO 从而使 POJO 发挥更大的功能。这样的好处是显而易见的，非侵入就意味着这个类在任何场所都可以使用。Spring 使用 POJO 的方式之一就是通过依赖注入来装配他们。</p>
<h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>首先什么是依赖，在一个工程中，相互协作的类就叫做相互依赖。举个例子，类 A 中有一个成员变量 B，则可以说 A 依赖 B。传统的编程中，需要自己管理与依赖的对象，比如 New 一个，或者销毁等等，这样必然带来高度的耦合以及增加测试难度。依赖注入能很好的解决这些问题。</p>
<p><strong>依赖注入</strong>（Dependency Injection，简称DI）可以看做是一个负责协调各对象的第三方组件，对象的依赖关系由这个第三方组件在创建对象的时候设定，它会将锁的关系自动交给目标对象，对象无需自己创建或者管理它们的依赖关系。</p>
<p>依赖注入能够让相互协作的软件组件保持松耦合。</p>
<h1 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h1><p><strong>面向切面编程</strong>（Aspect-oriented Programming，简称AOP）允许把遍布在应用软件各处的功能分离出来形成可重用的组件。</p>
<p>切面可以理解为横贯整个应用程序过程的一些功能，比如打印日志，缓存数据等等。</p>
<p><img src="http://blogqn.maintel.cn/aop.png?e=3080964974&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:I97zo1TVnBw25JBrS-L2PwnvQOs=" alt=""></p>
<p>最常见的通用功能实现技术是继承和委托，但是整个应用都使用相同的基类会使耦合度太高而且系统很脆弱，而委托可能需要对委托的对象进行复杂的调用。而面向切面就是将横贯整个应用的一些功能模块化为特殊的类，这些类就被成为切面（aspect）。</p>
<p>而 Spring 提供了四种对 AOP 的支持：</p>
<ul>
<li>基于代理的经典 Spring AOP；</li>
<li>纯 POJO 切面；</li>
<li>@AspectJ 注解驱动的切面；</li>
<li>注入式 AspectJ 切面。</li>
</ul>
<p>Spring AOP 的构建是建立在动态代理基础上的。</p>
<p>个人理解： DI 是帮助 Spring 组件间即应用对象间的解耦，而 AOP 则更注重的是功能间的解耦，即业务逻辑与横贯应用的通用功能间的解耦。</p>
<h1 id="Spring-模块"><a href="#Spring-模块" class="headerlink" title="Spring 模块"></a>Spring 模块</h1><p>Spring 框架包含20个不同的模块，在开发中可以根据不同需求选择不同的模块。</p>
<p><img src="http://blogqn.maintel.cn/Spring模块.png?e=3080971139&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:NHcqZb_6-Z-n5Qq9lflPdBMiJUk=" alt=""></p>
<ul>
<li><p>Spring 核心容器</p>
<p>  容器是 Spring 框架最核心的部分，它管理着 Spring 应用中 bean 的创建、配置和管理。还包括了 Spring bean 工厂、Spring 应用上下文、一些企业服务等。</p>
</li>
<li><p>面向切面编程</p>
<p>  在 AOP 模块中，Spring 对面向切面编程提供的支持就是基于该模块的。</p>
</li>
<li><p>数据访问与集成</p>
<p>  该模块提供了抽象了 JDBC 和 DAO 等的样板代码，使数据库连接服务变得简单，而且不用不关心数据库的关闭等操作。ORM 模块是对较为流行的 ORM 框架的集成， Hibernate、Java Data Object等。还包括消息服务，以及基于 AOP 模块的事务管理服务。</p>
</li>
<li><p>Web 与远程调用</p>
<p>  该模块提供了一个强大的 MVC 框架，同时还提供了一些其他远程调用框架 HTTP invoker，还提供了对 REST API 的支持。</p>
</li>
<li><p>Instrumentation</p>
<p>  提供了为 JVM 添加代理的功能，具体讲就是为 Tomcat 添加一个代理能够为 Tomcat 传递类文件。</p>
</li>
<li><p>测试</p>
<p>  Spring 专门提供了对 Spring 应用测试的支持，比如为单元测试提供 mock 对象的实现等。</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过上面的整理以及一些自己的理解，总算对 Spring 在整体上有一个理解，简单来说 Spring 是一个致力于让 Java 开发变得简单的框架，它的核心在于 DI 和 AOP，通过 DI 和 AOP 来实现代码以及功能模块间的松耦合。因此理解 DI 和 AOP 至关重要。</p>
<p>DI 是组装 Spring 组件的一种方式，在运行期赋予一个对象所依赖的对象。</p>
<p>AOP 能够将一些通用的功能模块化即切面。当 Spring 装配 bean 的时候，这些切面能够在运行期应用到目标对象。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不知不觉已经捣鼓了小半年的 Java 了，主要一直在使用 Spring boot 来开发，但是由于 Spring boot 使用起来太过简单了，虽然做了这么久但是对 Spring 框架、工作原理等还是一头雾水，很多东西不理解也不知道，所以决定从头开始看 Spring，从最基础最简单的 Spring 开始学习。本篇先来从概念的层面了解一下 Spring。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="https://maintel.github.io/categories/Spring/"/>
    
    
      <category term="spring" scheme="https://maintel.github.io/tags/spring/"/>
    
      <category term="spring boot" scheme="https://maintel.github.io/tags/spring-boot/"/>
    
      <category term="java后台" scheme="https://maintel.github.io/tags/java%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>[Android IPC] AIDL 的使用(二)</title>
    <link href="https://maintel.github.io//blog/2017/04/androidIPCAIDL2.html"/>
    <id>https://maintel.github.io//blog/2017/04/androidIPCAIDL2.html</id>
    <published>2017-04-06T07:08:50.000Z</published>
    <updated>2018-03-18T03:27:27.755Z</updated>
    
    <content type="html"><![CDATA[<p>关于 AIDL 的介绍以及基本使用请参看<a href="http://blog.maintel.cn/blog/2017/04/AndroidIPC-AIDL%E7%9A%84%E4%BD%BF%E7%94%A81.html" target="_blank" rel="external">上一篇</a>，本篇主要记录 AIDL 使用中的一些注意事项以及一些高级用法。</p>
<a id="more"></a>
<h1 id="使用监听"><a href="#使用监听" class="headerlink" title="使用监听"></a>使用监听</h1><p>还是接着上一篇博客中的例子，如果想要在客户端被动的接收一些数据，即服务端数据发生变化后通知客户端——观察者模式。</p>
<p>下面就以增加了新书然后通知客户端作为例子来实现：</p>
<p>首先肯定要定义一个接口起名叫 IOnNewBookAddedListener.aidl；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IOnNewBookAdded.aidl</span></div><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1.listener;</div><div class="line"></div><div class="line"><span class="comment">//手动引入 Book</span></div><div class="line"><span class="keyword">import</span> com.maintel.binderdemo1.model.Book;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOnNewBookAddedListener</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNewBookAdded</span><span class="params">(in Book newBook)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后再 IBookManager.aidl 中增加两个方法用来注册和取消注册；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.maintel.binderdemo1.model.Book;</div><div class="line"><span class="keyword">import</span> com.maintel.binderdemo1.listener.IOnNewBookAddedListener;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(IOnNewBookAddedListener listener)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterListener</span><span class="params">(IOnNewBookAddedListener listener)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后改造服务端实现新增加的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> RemoteCallbackList&lt;IOnNewBookAddedListener&gt; mListeners = <span class="keyword">new</span> RemoteCallbackList&lt;&gt;();  <span class="comment">//注意这里</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isServiceDestroyed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        ...</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServiceWorker()).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(IOnNewBookAddedListener listener)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            mListeners.register(listener);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterListener</span><span class="params">(IOnNewBookAddedListener listener)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            mListeners.unregister(listener);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceWorker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!isServiceDestroyed) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    Thread.sleep(<span class="number">5000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">int</span> id = mBookList.size() + <span class="number">1</span>;</div><div class="line">                Book b = <span class="keyword">new</span> Book(id, <span class="string">"new book*"</span> + id);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    onBookAdded(b);</div><div class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBookAdded</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        mBookList.add(book);</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = mListeners.beginBroadcast();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            IOnNewBookAddedListener listener = mListeners.getBroadcastItem(i);</div><div class="line">            <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</div><div class="line">                listener.onNewBookAdded(book);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        mListeners.finishBroadcast();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        isServiceDestroyed = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改客户端如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IBookManager bookManager;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> IOnNewBookAddedListener onNewBookAddedListener = <span class="keyword">new</span> IOnNewBookAddedListener.Stub() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewBookAdded</span><span class="params">(Book newBook)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            System.err.println(Thread.currentThread());  <span class="comment">//将当前线程打印出来</span></div><div class="line">            Log.d(<span class="string">"MainActivity$newbook"</span>, newBook.toString());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</div><div class="line">            Log.e(<span class="string">"MainActivity$Connected"</span>, <span class="string">"Thread.currentThread():"</span> + Thread.currentThread());<span class="comment">//将当前线程打印出来</span></div><div class="line">            bookManager = IBookManager.Stub.asInterface(iBinder);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                bookManager.registerListener(onNewBookAddedListener);</div><div class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</div><div class="line">            Log.e(<span class="string">"MainActivity$Disconnect"</span>, <span class="string">"Thread.currentThread():"</span> + Thread.currentThread());<span class="comment">//将当前线程打印出来</span></div><div class="line">            bookManager = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (bookManager != <span class="keyword">null</span> &amp;&amp; bookManager.asBinder().isBinderAlive()) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                bookManager.unregisterListener(onNewBookAddedListener);</div><div class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        unbindService(mConnection);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就实现了一个简单的监听，每隔五秒会打印一条书籍的信息。</p>
<p>接下来就要说一些注意事项了，通过上面的代码可以发现在记录 IOnNewBookAddedListener 监听集合的时候使用了 RemoteCallbackList，而不是一般常用的 ArrayList 等为什么呢？</p>
<h1 id="RemoteCallbackList"><a href="#RemoteCallbackList" class="headerlink" title="RemoteCallbackList"></a>RemoteCallbackList</h1><p>虽然常用的注册与解注册方法是传递相同的对象，而且上面也确实传递了同样的对象，但是首先要明白 AIDL 是用来实现多进程通讯的，其底层的 Binder 机制会把客户端传递过来的对象重新转化成一个新的对象，因此即使我们传递了相同的对象来解注册，但是到服务端的时候已经是一个新的对象了。这也是为什么使用自定义的对象的时候必须要实现 Parcelable 接口的原因。</p>
<p>RemoteCallbackList 是系统专门提供用于删除跨进程 listener 的接口，其内部维护了一个 Map 结构来保存所有的 AIDL 回调。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ArrayMap&lt;IBinder,Callback&gt; mCallbacks = <span class="keyword">new</span> ArrayMap&lt;IBinder,Callback&gt;();</div></pre></td></tr></table></figure>
<p>另外 RemoteCallbackList 在客户端进程终止后，会自动清除客户端注册的 listener，而且其内部实现了线程同步功能。</p>
<p>这里要注意的是遍历 RemoteCallbackList 的方法，只能使用下面的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = callbacks.beginBroadcast();</div><div class="line"><span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">    i--;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        callbacks.getBroadcastItem(i); <span class="comment">// 获取回调</span></div><div class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">       </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">callbacks.finishBroadcast();</div></pre></td></tr></table></figure>
<p>beginBroadcast() 和 finishBroadcast() 一定要配合使用。</p>
<h1 id="注意-listener-回调所在线程"><a href="#注意-listener-回调所在线程" class="headerlink" title="注意 listener 回调所在线程"></a>注意 listener 回调所在线程</h1><p>当服务端回调 listener 中的方法时，被回调的方法运行在客户端的 Binder 线程池中，所以当<strong>回调需要操作 UI 时记得将线程切换到 UI 线程</strong>，同时，如果客户端回调方法要执行大量耗时操作时，会阻塞服务端发起回调的方法，因此要确保<strong>当客户端回调方法执行耗时操作是，服务端发起回调的方法不要运行在 UI 线程中</strong>。就像例子中 BookManagerService 的 onBookAdded 方法，它调用了客户端的 IOnNewBookAddedListener 的 onNewBookAdded 方法，如果客户端的这个 onNewBookAdded 方法比较耗时的话，要确保 onBookAdded 方法运行在非 UI 线程中。</p>
<h1 id="注意耗时操作"><a href="#注意耗时操作" class="headerlink" title="注意耗时操作"></a>注意耗时操作</h1><p>由于服务端方法本身运行在服务端的 Binder 线程池中，所以服务端的方法本身可以执行大量耗时操作，但是如果在客户端的 UI 线程中调用服务端的耗时方法的话就可能触法 ANR 异常，因为<strong>当客户端调用服务端方法时客户端的现成会被挂起直到服务端执行完毕</strong>。</p>
<p>所以当需要调用服务端的耗时方法时，客户端请务必放在子线程中操作。</p>
<h1 id="死亡监听"><a href="#死亡监听" class="headerlink" title="死亡监听"></a>死亡监听</h1><p>可以有两个方法对 Service 的异常结束做监听。</p>
<ul>
<li><p>给 Binder 添加 DeathRecipient 监听，当 Binder 死亡时会收到 binderDeid 回调</p>
<p>  此方法运行在 Binder 线程池中。</p>
</li>
<li><p>在 onServiceDisconnected 中做监听，当 Service 异常结束时会调用此方法</p>
<p>  此方法运行在 UI 线程中。</p>
</li>
</ul>
<h1 id="权限检查"><a href="#权限检查" class="headerlink" title="权限检查"></a>权限检查</h1><ul>
<li>可以通过自定义权限然后在 onBind 中进行权限验证；</li>
<li>通过自定义权限在 onTransact 中进行验证；</li>
<li>通过 Uid 和Pid 在 onTransact 中进行验证；</li>
<li>为 Service 制定 android:permission 属性来验证；</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Android 开发艺术探索》-任玉刚</li>
<li><a href="https://developer.android.google.cn/guide/components/aidl.html?hl=zh-cn#PassingObjects" target="_blank" rel="external">Android 接口定义语言 (AIDL)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 AIDL 的介绍以及基本使用请参看&lt;a href=&quot;http://blog.maintel.cn/blog/2017/04/AndroidIPC-AIDL%E7%9A%84%E4%BD%BF%E7%94%A81.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一篇&lt;/a&gt;，本篇主要记录 AIDL 使用中的一些注意事项以及一些高级用法。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="跨进程" scheme="https://maintel.github.io/tags/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="IPC" scheme="https://maintel.github.io/tags/IPC/"/>
    
      <category term="Binder" scheme="https://maintel.github.io/tags/Binder/"/>
    
      <category term="AIDL" scheme="https://maintel.github.io/tags/AIDL/"/>
    
  </entry>
  
  <entry>
    <title>[Android IPC] AIDL 的使用(一)</title>
    <link href="https://maintel.github.io//blog/2017/04/AndroidIPC-AIDL%E7%9A%84%E4%BD%BF%E7%94%A81.html"/>
    <id>https://maintel.github.io//blog/2017/04/AndroidIPC-AIDL的使用1.html</id>
    <published>2017-04-04T09:49:35.000Z</published>
    <updated>2018-03-18T03:27:20.276Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h1><p>AIDL(Android Interface Definition Language) 翻译成中文就是 Android 接口定义语言，用于生成 Android 设备上两个进程之间进行通讯的代码。它是 Binder 机制向外提供的接口，它使用代理类在客户端和服务端传递数据。</p>
<a id="more"></a>
<p>本篇主要记录 AIDL 学习过程以及一些坑。</p>
<h1 id="AIDL-的使用"><a href="#AIDL-的使用" class="headerlink" title="AIDL 的使用"></a>AIDL 的使用</h1><p>AIDL 的使用主要分为以下三步：</p>
<ul>
<li><p>创建 .aidl 文件</p>
<p>  即 AIDL 接口，是服务端暴露给客户端的接口，服务端和客户端其实就是通过这些接口来通讯的。</p>
</li>
<li><p>服务端</p>
<p>  创建一个 service 用来监听客户端的请求，然后再其中实现定义好的 AIDL 接口即可。</p>
</li>
<li><p>客户端</p>
<p>  绑定服务端的 service，将服务端返回的 Binder 对象转换成 AIDL 接口类型，接着调用 AIDL 中的方法就可以了。</p>
</li>
</ul>
<h2 id="创建-aidl-文件"><a href="#创建-aidl-文件" class="headerlink" title="创建 .aidl 文件"></a>创建 .aidl 文件</h2><p>这里有一个 Book 类，服务端与客户端之间传递的主要数据实体就是它了。在创建 .aidl 文件前先建立此类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1.model;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> boolId;</div><div class="line">    <span class="keyword">private</span> String bookName;</div><div class="line"></div><div class="line">    ...<span class="comment">//为了节省篇幅这里省略了一些代码，get set 以及 实现 Parcelable 接口的一些代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里为什么要实现 Parcelable 是因为 AIDL 在实现进程间通讯的过程时就是一个对数据序列化和反序列化的过程。</p>
<p>AIDL 文件支持的数据类型如下：</p>
<ul>
<li>Java 编程语言中的所有原语类型（如 int、long、char、boolean 等等）</li>
<li>String 和 CharSequence</li>
<li><p>List</p>
<p>  List 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或声明的可打包类型。 可选择将 List 用作“通用”类（例如，List<string>）。另一端实际接收的具体类始终是 ArrayList，但生成的方法使用的是 List 接口。</string></p>
</li>
<li><p>Map</p>
<p>  Map 中的所有元素都必须是以上列表中支持的数据类型、其他 AIDL 生成的接口或声明的可打包类型。 不支持通用 Map（如 Map<string,integer> 形式的 Map）。 另一端实际接收的具体类始终是 HashMap，但生成的方法使用的是 Map 接口。</string,integer></p>
</li>
<li><p>实现了 Parcelable 接口的对象</p>
</li>
</ul>
<p>下面就来创建所需的 .aidl 文件</p>
<p>快速创建 aidl 文件可以如下步骤：</p>
<p><img src="http://blogqn.maintel.cn/创建aidl1.png?e=3080192722&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:luqc2vxLIk7QCHtY5x0wIBXxUss=" alt=""></p>
<p>因为用到了 Book 这个类，所以也要创建 Book.aidl 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Book.aidl</span></div><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1.model;</div><div class="line"></div><div class="line">parcelable Book;  <span class="comment">//注意这里的 parcelable 和 Parcelable 不一样，前者是一个类型</span></div></pre></td></tr></table></figure>
<p><em>注意这里<code>package com.maintel.binderdemo1.model</code>必须要和 Book 类的包名一致！要不然在自动生成的时候会找不到类</em></p>
<p>然后创建接口类 IBookManager.aidl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// IBookManager.aidl</span></div><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1;</div><div class="line"></div><div class="line"><span class="comment">// Declare any non-default types here with import statements</span></div><div class="line"><span class="keyword">import</span> com.maintel.binderdemo1.model.Book;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IBookManager</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(in Book book)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于上面的代码：</p>
<ul>
<li><p><code>import com.maintel.binderdemo1.model.Book;</code></p>
<p>  因为下面的方法中用到的 Book, 所以我们需要显式的引入进来，即使有时候两者在同一个包下。</p>
</li>
<li><p><code>void addBook(in Book book);</code> 中的 in</p>
<p>  除了基本数据类型外，其他的类型参数必须标上 in、out、inout，in 表示输入型参数，out 表示输出型参数，inout 表示输入输出型参数。</p>
</li>
</ul>
<p>至此接口类就已经完成了，此时 build 一下项目如果使用的是 Android studio 会在 app/build/generated/source/aidl/debug/package name 下看到自动生成的 IBookManager。</p>
<h2 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h2><p>服务端就很简单了，首先新建一个名为 BookManagerService 的 service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.maintel.binderdemo1.service;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookManagerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> CopyOnWriteArrayList&lt;Book&gt; mBookList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">1</span>, <span class="string">"Java"</span>));</div><div class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">2</span>, <span class="string">"JS"</span>));</div><div class="line">        mBookList.add(<span class="keyword">new</span> Book(<span class="number">3</span>, <span class="string">"Android"</span>));</div><div class="line">    &#125;   </div><div class="line"></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mBinder;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Binder mBinder = <span class="keyword">new</span> IBookManager.Stub() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBookList</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            <span class="keyword">return</span> mBookList;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">            mBookList.add(book);</div><div class="line">        &#125;</div><div class="line">    &#125;; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里使用了 CopyOnWriteArrayList 它不是继承自 ArrayList 的，但是为什么可以使用呢？是因为 AIDL 支持的是抽象的 List 接口，因此虽然服务端返回的是 CopyOnWriteArrayList，但是在 Binder 中还是按照 List 的规范去访问数据，最终形成一个 ArrayList 返回给客户端。</p>
<p>在清单文件中注册，并使其运行在另外的进程中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">".service.BookManagerService"</span></div><div class="line">    <span class="attr">android:process</span>=<span class="string">":remote"</span>/&gt;</div></pre></td></tr></table></figure>
<h2 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h2><p>客户端的实现就是一个绑定 service 的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IBookManager bookManager;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName componentName, IBinder iBinder)</span> </span>&#123;</div><div class="line">            bookManager = IBookManager.Stub.asInterface(iBinder);</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                bookManager.addBook(<span class="keyword">new</span> Book(<span class="number">4</span>,<span class="string">"Html"</span>)); <span class="comment">//这里调用 addBook 添加一本书</span></div><div class="line">                List&lt;Book&gt; list = bookManager.getBookList();</div><div class="line">                Log.d(<span class="string">"MainActivity"</span>, list.toString());</div><div class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName componentName)</span> </span>&#123;</div><div class="line">            Log.d(<span class="string">"MainActivity.onServiceDisconnected"</span>);</div><div class="line">            bookManager = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        Log.e(<span class="string">"MainActivity"</span>, <span class="string">"Thread.currentThread():"</span> + Thread.currentThread());</div><div class="line">        Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</div><div class="line">        bindService(intent, mConnection, BIND_AUTO_CREATE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        unbindService(mConnection);</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时运行客户端程序打印出 log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D/MainActivity: [Book&#123;boolId=1, bookName=&apos;Java&apos;&#125;, Book&#123;boolId=2, bookName=&apos;JS&apos;&#125;, Book&#123;boolId=3, bookName=&apos;Android&apos;&#125;, Book&#123;boolId=4, bookName=&apos;Html&apos;&#125;]</div></pre></td></tr></table></figure>
<p>至此一次完整的使用 AIDL 进行 IPC 的过程就完成了。</p>
<p>至于其使用过程中的一些注意事项后面再说。</p>
<h1 id="关于-AIDL-的理解"><a href="#关于-AIDL-的理解" class="headerlink" title="关于 AIDL 的理解"></a>关于 AIDL 的理解</h1><p>我个人关于 AIDL 的一些理解，不知道是否准确</p>
<p>AIDL 是一门语言，它是为了更方便的使用 Binder 而生的。按照规范写一个 .aidl 文件，插件会自动生成同名的 java 文件，而这些 java 文件才是具体实现，为什么要有 AIDL 其实是为了更标准化以及简化 Binder 的使用，让开发者更多的关注与功能的实现上。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Android 开发艺术探索》-任玉刚</li>
<li><a href="https://developer.android.google.cn/guide/components/aidl.html?hl=zh-cn#PassingObjects" target="_blank" rel="external">Android 接口定义语言 (AIDL)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AIDL&quot;&gt;&lt;a href=&quot;#AIDL&quot; class=&quot;headerlink&quot; title=&quot;AIDL&quot;&gt;&lt;/a&gt;AIDL&lt;/h1&gt;&lt;p&gt;AIDL(Android Interface Definition Language) 翻译成中文就是 Android 接口定义语言，用于生成 Android 设备上两个进程之间进行通讯的代码。它是 Binder 机制向外提供的接口，它使用代理类在客户端和服务端传递数据。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="跨进程" scheme="https://maintel.github.io/tags/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="IPC" scheme="https://maintel.github.io/tags/IPC/"/>
    
      <category term="Binder" scheme="https://maintel.github.io/tags/Binder/"/>
    
      <category term="AIDL" scheme="https://maintel.github.io/tags/AIDL/"/>
    
  </entry>
  
  <entry>
    <title>git 使用中出现问题</title>
    <link href="https://maintel.github.io//blog/2017/03/encountered-%E9%94%99%E8%AF%AF.html"/>
    <id>https://maintel.github.io//blog/2017/03/encountered-错误.html</id>
    <published>2017-03-15T15:26:33.000Z</published>
    <updated>2018-03-18T03:38:39.242Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p><em>2018-03-15更新</em></p>
<h1 id="Fatal-HttpRequestException-encountered"><a href="#Fatal-HttpRequestException-encountered" class="headerlink" title="Fatal: HttpRequestException encountered."></a>Fatal: HttpRequestException encountered.</h1><p>git 提交时出现 Failed with error: Fatal: HttpRequestException encountered 错误，并且一直提示登录。</p>
<p>经过查阅资料发现是 git 官方进行了更新(<a href="https://githubengineering.com/crypto-removal-notice/" target="_blank" rel="external">参看这里</a>)。主要是从2018年2月8号开始禁用一下内容：</p>
<ul>
<li><p>TLSv1/TLSv1.1</p>
</li>
<li><p>diffie-hellman-group1-sha1</p>
</li>
<li><p>diffie-hellman-group14-sha1</p>
</li>
</ul>
<p>引起问题的就是第一条，因为 win 的 git 凭证管理器1.14以下版本不支持 TLSv1.2，所以要进行升级<a href="https://github.com/Microsoft/Git-Credential-Manager-for-Windows/releases/tag/v1.14.0" target="_blank" rel="external">下载地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;&lt;em&gt;2018-03-15更新&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&quot;Fatal-HttpRequestException-encountered&quot;&gt;&lt;a href=&quot;#Fatal-HttpRequestException-encountered&quot; class=&quot;h
    
    </summary>
    
      <category term="工具与配置" scheme="https://maintel.github.io/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="https://maintel.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>jenkins+gradle+git持续集成</title>
    <link href="https://maintel.github.io//blog/2017/03/jenkins-gradle-git%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90.html"/>
    <id>https://maintel.github.io//blog/2017/03/jenkins-gradle-git持续集成.html</id>
    <published>2017-03-15T07:01:55.000Z</published>
    <updated>2018-03-18T03:27:34.958Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章的目标是实现一个基于 Jenkins、Gradle、git的持续集成环境。</p>
<p>上一篇实现了 <a href="http://blog.maintel.cn/blog/2017/03/gradle%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE-%E4%B8%80.html" target="_blank" rel="external">gradle 自动化构建</a>的功能，但是总是觉得不够智能，有没有一种办法可以使程序自动打包完成并通知相关人员呢？答案就是本篇要讲的 Jenkins。</p>
<a id="more"></a>
<h1 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h1><p><strong>持续集成（Continuous Integration）</strong></p>
<p>首先是持续集成，我知道持续集成还是从做后台的哥们儿那里，概念就如字面意思：</p>
<blockquote>
<p>持续集成指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
</blockquote>
<p>与持续集成相关的，还有两个概念，分别是持续交付和持续部署。</p>
<p><strong>持续交付（Continuous delivery）</strong></p>
<blockquote>
<p>频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
</blockquote>
<p><strong>持续部署（continuous deployment）</strong></p>
<blockquote>
<p>持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。</p>
</blockquote>
<p>简单看概念来说本篇文章实现的功能是持续集成和持续交付，即代码持续集成后自动打包生产出测试包然后通知测试人员测试，而不用开发人员再手动的去打包发送等。</p>
<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p><a href="https://jenkins.io/" target="_blank" rel="external">Jenkins</a> 是一个开源的持续集成工具，可以用它来实现持续集成，同样功能的软件还有 </p>
<ul>
<li><a href="https://travis-ci.com/" target="_blank" rel="external">Travis</a></li>
<li><a href="https://www.codeship.io/" target="_blank" rel="external">Codeship</a></li>
<li><a href="http://stridercd.com/" target="_blank" rel="external">Strider</a></li>
</ul>
<p>下面就来实践一个持续集成的工程。</p>
<h1 id="安装-Jenkins"><a href="#安装-Jenkins" class="headerlink" title="安装 Jenkins"></a>安装 Jenkins</h1><p>首先在<a href="https://jenkins.io/download/" target="_blank" rel="external">这里</a>下载 Jenkins，Jenkins 官方提供了 war 包以及其他的个各种操作系统的安装程序。windows 平台下可以有两个选择：</p>
<ul>
<li><p>war 包</p>
<p>  只需运行 java -jar jenkins.war 即可</p>
</li>
<li><p>msi 文件</p>
<p>  直接运行即可</p>
</li>
</ul>
<p>本篇文章选用安装文件的方式，安装成功后会自动访问 <code>http://localhost:8080</code> ,并自动生成一个随机的密码在 <code>root\jenkins\secrets\initialAdminPassword</code>。如果启动不能成功，可能端口号冲突修改一个端口号即可。</p>
<p>修改端口号方法:打开 <code>root\jenkins.xml</code>找到<code>--httpPort=8080</code>修改，然后执行<code>net stop jenkins</code>和<code>net start jenkins</code>重启 Jenkins（如果提示拒绝访问，使用管理员权限）。</p>
<p>重新访问修改后的地址，然后填入密码等待刷新完成。</p>
<p>然后选择安装插件，我是直接选择左边使用推荐来自动完成，也可以选择右边自定义其中几个重要的插件 Gradle(gradle plugin)、git(git plugin)、邮件(email extension plugin)等。</p>
<p>等待插件下载完成要创建一个用户，创建完成即进入首页。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829114554.png?e=3080777649&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:ggLh6k9SXOxaJd0jgv7VPWrkYbs=" alt=""></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><ul>
<li>权限配置</li>
</ul>
<p>系统管理 - Configure Global Security，通过安全矩阵对不同角色或者组进行权限配置，具体说明请自行google。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829145712.png?e=3080789153&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:g05yRNWoxALajGkXxisnZTUD_1c=" alt=""></p>
<ul>
<li><p>gradle插件配置</p>
<p>gradle 插件等进行配置,这里主要是为了防止项目配置中的 gradle 和 android 项目的 gradle 版本不同导致构建失败。</p>
</li>
</ul>
<p>系统管理 - Global Tool Configuration</p>
<p>选择 gradle配置,配置常用的 gradle 版本。可以手动指定目录，也可以选择自动安装。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829115828.png?e=3080778403&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:PFPIh4V-L4tEXNq1XZhvtUKkvrE=" alt=""></p>
<ul>
<li>邮件服务器配置</li>
</ul>
<p>系统管理 - 系统设置。</p>
<p>这里要注意 SMTP认证 的邮箱一定要和上面 Jenkins Location 设置中系统管理员邮件地址一样，不然不能成功。配置完成可以使用测试邮件提示 <code>Email was successfully sent</code> 则代表成功。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829143712.png?e=3080787927&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:J-8IRzHuAhyABZ5nI8zC1bwXhJQ=" alt=""></p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>这里假设已经有一个android gradle项目名为 JenkinsTest，并已经推送到 git 远程仓库。</p>
<ul>
<li>点击创建一个新任务</li>
</ul>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829114902.png?e=3080777839&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:XAe_RUlK7xKDDkgHs64OkG8KlJ8=" alt=""></p>
<p>这里选择<code>构建一个自由风格的软件项目</code>。选择 ok 配置项目</p>
<ul>
<li>源码管理选择 git 填入 git 项目地址</li>
</ul>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829141008.png?e=3080786413&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:lZYyiqufEgNYNbpRV7r84Z2ajXY=" alt=""></p>
<p>这里可以全局配置好直接选择账号，也可以设置 git 账号，点击<code>add</code>，</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829141036.png?e=3080786589&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:NHzIV4cikgmtVy6yHRa5e6BZba4=" alt=""></p>
<ul>
<li>配置构建触发器</li>
</ul>
<p>这里选择使用 <code>Poll SCM</code> (定时检查源码变更)，Jenkins 会根据配置定期的检查更新，如果有更新就下载并进行构建。他的语法如下：</p>
<p>总共有五个参数 <em> \</em> * * *,</p>
<p>第一个参数代表的是分钟 minute，取值 0~59；</p>
<p>第二个参数代表的是小时 hour，取值 0~23；</p>
<p>第三个参数代表的是天 day，取值 1~31；</p>
<p>第四个参数代表的是月 month，取值 1~12；</p>
<p>最后一个参数代表的是星期 week，取值 0~7，0 和 7 都是表示星期天。</p>
<p>H/5 * * * * 就代表每五分钟检查一次。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829141741.png?e=3080786790&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:Ym2PmBqmpTyYqIo2cX_K_favKGM=" alt=""></p>
<ul>
<li>构建工具</li>
</ul>
<p>增加构建步骤 - <code>Invoke Gradle script</code>，然后选择 Gradle 的版本，在 Tasks 中增加构建的命令</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829142837.png?e=3080787407&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:THm64jdST0OAq6GJ4exdze8ByqA=" alt=""></p>
<ul>
<li>构建后操作</li>
</ul>
<p>将生成的 apk 输出保存出来，如果没有在 gradle 中配置 apk 的输出路径，则默认为 <code>app/build/outputs/apk/*.apk</code>，还可以选择发送邮件通知相关人员比如测试。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829144316.png?e=3080788431&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:e5UyTjmxA0ZSd6Xy-O166O7WuO0=" alt=""></p>
<p>至此，所有配置已经完成。</p>
<h1 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h1><p>配置完成以后项目目录</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829160457.png?e=3080793212&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:FexLRdQn-HRDOnGkFhribYCMw80=" alt=""></p>
<p>可以点击工作空间查看获取的代码是否正确。</p>
<p>可以在构建历史列表看到一些以往的构建结果，点击进入可以看到一些构建结果，包含git的信息等。</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829160514.png?e=3080793212&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:-a7nunCz7T9VbJWHVN44cRS5fwM=" alt=""></p>
<p>在 Console Output 中可以看到控制台的编译输出，如果编译失败可以在这里找到一些有用的信息</p>
<p><img src="http://blogqn.maintel.cn/TIM截图20170829145153.png?e=3080788978&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:2g8DWpNwJbOrXYbasJCQolqDpe0=" alt=""></p>
<p>以上一个简单的使用 Jenkins、Gradle、git 的持续集成环境就搭建完成了，每次将代码合并到主分支 push 以后就会自动打包，并通知相关人员。</p>
<p>乍一看觉得作用不大，不过仔细想想好像还是有那么点用的额。算是偷懒吧，不用每次手动打包然后再去上传包到测试平台等等，而且不单单是 Android 主要是后台可以在自动构建完成后执行脚本重启服务自动部署等等，作用也挺大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章的目标是实现一个基于 Jenkins、Gradle、git的持续集成环境。&lt;/p&gt;
&lt;p&gt;上一篇实现了 &lt;a href=&quot;http://blog.maintel.cn/blog/2017/03/gradle%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE-%E4%B8%80.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gradle 自动化构建&lt;/a&gt;的功能，但是总是觉得不够智能，有没有一种办法可以使程序自动打包完成并通知相关人员呢？答案就是本篇要讲的 Jenkins。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="自动化" scheme="https://maintel.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="jenkins" scheme="https://maintel.github.io/tags/jenkins/"/>
    
      <category term="持续集成" scheme="https://maintel.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>gradle自动构建配置(一)</title>
    <link href="https://maintel.github.io//blog/2017/03/gradle%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA%E9%85%8D%E7%BD%AE-%E4%B8%80.html"/>
    <id>https://maintel.github.io//blog/2017/03/gradle自动构建配置-一.html</id>
    <published>2017-03-05T08:18:34.000Z</published>
    <updated>2018-03-18T03:27:52.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在日常的开发中，特别是进入版本快速迭代的时候，需要不停的修改配置，测试环境、线上环境配置，测试包、正式包的打包等等，不但过程繁琐而且还容易出错，所以查询了相关资料尽量实现自动化配置。</p>
<a id="more"></a>
<p>目标：</p>
<ul>
<li><p>根据构建环境自动配置代码参数。</p>
</li>
<li><p>自动打包不同的KEY的app。</p>
</li>
<li><p>apk输出路径和名称配置。</p>
</li>
</ul>
<p>接下来就开始吧。</p>
<h1 id="技术概要"><a href="#技术概要" class="headerlink" title="技术概要"></a>技术概要</h1><p>本文的目标主要都是通过修改 app/build.gradle 文件来实现的。</p>
<blockquote>
<p>gradle 提供了构建项目的一个框架，而它本身来使用 Groovy 来声明设置，Groovy 本身也可以理解成一个语言，有自己的语法、可执行等等，在越来越多使用 gradle 来构建项目的今天，其实学习它的语法也是很有必要的。</p>
</blockquote>
<h1 id="根据构建环境自动配置代码参数"><a href="#根据构建环境自动配置代码参数" class="headerlink" title="根据构建环境自动配置代码参数"></a>根据构建环境自动配置代码参数</h1><p>可能概括的不是很好，举个例子就是在项目开发过程中，测试开发环境和线上环境肯定不会使用同样的服务器，这里就是通过 gradle 来实现自动化的配置。</p>
<p>下面就通过这个例子来说明。</p>
<p>例如之前的代码：</p>
<p><img src="http://blogqn.maintel.cn/自动化构建服务器接口old.png?e=3079754286&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:FbLV8JK8VcdWxKaoVWkgHhE3fkI=" alt="自动化构建old接口"></p>
<p>每次发版的时候都要修改上面的代码来切换接口环境，这样做虽然不是很麻烦，但是毕竟不够优雅，而且保不准哪次就忘了。所以引入了自动化构建。</p>
<p>首先在 app/bulid.gradle 中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">     buildTypes &#123;</div><div class="line">          release &#123;</div><div class="line">              buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://www.google.com/\&quot;&quot;)</div><div class="line">              buildConfigField(&quot;String&quot;, &quot;Base_QINIU&quot;, &quot;\&quot;http://www.qiniu.com/\&quot;&quot;)</div><div class="line">          &#125;</div><div class="line">          debug&#123;</div><div class="line">              debuggable true  //表示是debug版本</div><div class="line">              buildConfigField(&quot;String&quot;, &quot;BASE_URL&quot;, &quot;\&quot;http://www.baidu.com/\&quot;&quot;)</div><div class="line">              buildConfigField(&quot;String&quot;, &quot;Base_QINIU&quot;, &quot;\&quot;http://www.qiniu.com/\&quot;&quot;)</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先 ReBuild 一下，然后修改之前接口文件代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String BASE_URL = BuildConfig.BASE_URL; </div><div class="line">String Base_QINIU = BuildConfig.Base_QINIU;</div></pre></td></tr></table></figure>
<p>这样再直接运行的时候就会自动使用 debug 版本的接口，而正式打包的时候则会使用正式的接口。</p>
<h1 id="自动打包不同KEY的app"><a href="#自动打包不同KEY的app" class="headerlink" title="自动打包不同KEY的app"></a>自动打包不同KEY的app</h1><p>同样的可以通过配置来实现一次打包不同签名文件的apk。配置方法如下：</p>
<p>还是在 app/build.gradle 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line"></div><div class="line">    signingConfigs &#123;</div><div class="line">        release &#123;</div><div class="line">            keyAlias &apos;blelock&apos;  //别名</div><div class="line">            keyPassword &apos;xxxx&apos;  //别名密码</div><div class="line">            storeFile file(&apos;../lockBle.jks&apos;)  //文件路径  默认根目录为app下，所以 ../代表app目录的上级目录</div><div class="line">            storePassword &apos;xxxx&apos;  //密码</div><div class="line">        &#125;</div><div class="line">        debug &#123;</div><div class="line">            keyAlias &apos;blelock_debug&apos;</div><div class="line">            keyPassword &apos;xxxx&apos;</div><div class="line">            storeFile file(&apos;../lockBle_debug.jks&apos;)</div><div class="line">            storePassword &apos;xxxx&apos;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     buildTypes &#123;</div><div class="line">          release &#123;</div><div class="line">              signingConfig signingConfigs.release  //使用 release 配置的key</div><div class="line">          &#125;</div><div class="line">          debug&#123;</div><div class="line">              debuggable true  //表示是debug版本</div><div class="line">              signingConfig signingConfigs.debug   //使用 debug 配置的key</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后点击 Android studio 中最右边的 Gradle 标签，点击 root - Tasks - build 双击执行 assemble 等待执行完以后，就能在 app/build/outputs/apk 文件夹下看到两个文件，分别为 app-debug.apk 和 app-release.apk。</p>
<p><img src="http://blogqn.maintel.cn/执行build-assemable.png?e=3079756136&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:nQFiJGPF10NwJMFzBcUY_bUkPJE=" alt=""></p>
<p><img src="http://blogqn.maintel.cn/自动签名apk1.png?e=3079756181&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:FataGEYtRIL2PjEKHjWpN_d10E0=" alt=""></p>
<h1 id="apk-输出路径和名称配置"><a href="#apk-输出路径和名称配置" class="headerlink" title="apk 输出路径和名称配置"></a>apk 输出路径和名称配置</h1><p>通过上面实现了自动对 apk 进行不同签名的功能，但是输出 apk 包的位置和名称不够理想和直观，所以再接着进行修改,添加如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    ...</div><div class="line">     buildTypes &#123;</div><div class="line">          release &#123;</div><div class="line">            applicationVariants.all &#123; variant -&gt;</div><div class="line">                variant.outputs.each &#123; output -&gt;</div><div class="line">                    def outputFile = output.outputFile</div><div class="line">                    def fileName;</div><div class="line">                    if (outputFile != null &amp;&amp; outputFile.name.endsWith(&apos;.apk&apos;)) &#123;</div><div class="line">                        if (variant.buildType.name.equals(&apos;release&apos;)) &#123;  </div><div class="line">                            fileName = &quot;apk$&#123;defaultConfig.versionName&#125;.apk&quot;  //修改正式包的名称 为 apk+版本号.apk</div><div class="line">                        &#125; else if (variant.buildType.name.equals(&apos;debug&apos;)) &#123;</div><div class="line">                            //修改测试包的名称为 apk+版本号-test.apk</div><div class="line">                            fileName = &quot;AiLock$&#123;defaultConfig.versionName&#125;-test.apk&quot;  </div><div class="line">                        &#125;</div><div class="line">                        output.outputFile = new File(&quot;./apk&quot;, fileName)  //修改输出路径为 根/apk 文件夹下，没有则会自动创建</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后同样执行上面的 assemble 以后，会在项目根目录生成一个 apk文件夹。</p>
<p><img src="http://blogqn.maintel.cn/生成的apk.png?e=3079757689&amp;token=kDSqSAyKGaf8JcHprWP7S4W3hGuz8kDIEhzAufWH:RtTmEq3ha-pR5aT66b4EugAxx3Q=" alt=""></p>
<p>以上就是一个简单的自动化配置的过程，当然还有很多其他的配置，以后慢慢研究吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;在日常的开发中，特别是进入版本快速迭代的时候，需要不停的修改配置，测试环境、线上环境配置，测试包、正式包的打包等等，不但过程繁琐而且还容易出错，所以查询了相关资料尽量实现自动化配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="gradle" scheme="https://maintel.github.io/tags/gradle/"/>
    
      <category term="自动化" scheme="https://maintel.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>android编译异常&#39;prepareDebugAndroidTestDependencies&#39;</title>
    <link href="https://maintel.github.io//blog/2017/02/android%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8-prepareDebugAndroidTestDependencies.html"/>
    <id>https://maintel.github.io//blog/2017/02/android编译异常-prepareDebugAndroidTestDependencies.html</id>
    <published>2017-02-20T09:08:41.000Z</published>
    <updated>2018-03-18T03:29:18.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Error-Execution-failed-for-task-‘-app-prepareDebugAndroidTestDependencies’"><a href="#Error-Execution-failed-for-task-‘-app-prepareDebugAndroidTestDependencies’" class="headerlink" title="Error:Execution failed for task ‘:app:prepareDebugAndroidTestDependencies’."></a>Error:Execution failed for task ‘:app:prepareDebugAndroidTestDependencies’.</h1><a id="more"></a>
<p>今天在测试<a href="https://google.github.io/dagger//" target="_blank" rel="external">Dagger2</a>时遇到异常，运行是能够通过的，但是build时出现下面异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error:Execution failed for task &apos;:app:prepareDebugAndroidTestDependencies&apos;.</div></pre></td></tr></table></figure>
<p><img src="http://orzoelfvh.bkt.clouddn.com/AS%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B81.png?attname=&amp;e=1498561805&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:j7-nGaeIuTsKDoezJMJ_xHmYxFk" alt="ASyichang"></p>
<p>最后在<a href="https://stackoverflow.com/questions/30558737/execution-failed-for-task-apppreparedebugandroidtestdependencies" target="_blank" rel="external">stackoverflow</a>上找到答案。</p>
<pre><code>在app的build.gradle的android { }中添加如下代码即可：

configurations.all {
    resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.1&apos;
}
</code></pre><p>具体原因是因为：</p>
<pre><code>When instrumentation tests are run, both the main APK and test APK share the same classpath. Gradle build 

will fail if the main APK and the test APK use the same library (e.g. Guava) but in different versions. If 

gradle didn&apos;t catch that, your app could behave differently during tests and during normal run (including 

crashing in one of the cases).

To make the build succeed, just make sure both APKs use the same version. If the error is about an indirect 

dependency (a library you didn&apos;t mention in your build.gradle), just add a dependency for the newer version 

to the configuration (&quot;compile&quot; or &quot;androidTestCompile&quot;) that needs it. You can also use Gradle&apos;s resolution 

strategy mechanism. You can inspect the dependency tree by running ./gradlew :app:dependencies and ./gradlew 

:app:androidDependencies.
</code></pre><p>大致意思就是：</p>
<pre><code>当运行测试时，主APK和测试APK共享类的路径，当主APK和测试APK使用相同的库但是是不同版本时就会出现这样的错误。
</code></pre><h2 id="另外的解决办法"><a href="#另外的解决办法" class="headerlink" title="另外的解决办法"></a>另外的解决办法</h2><p>除了上面的方案，还有另外一种解决方案，同样来源于<a href="https://stackoverflow.com/questions/36833606/android-support-library-error-after-updating-to-23-3-0/37717407#37717407" target="_blank" rel="external">stackoverflow</a>。</p>
<p>将<code>androidTestCompile</code>替换为<code>androidTestCompile &#39;com.android.support:support-annotations:xx.xx.x&#39;</code>其中xx.xx.x和项目引入的<code>com.android.support:appcompat-v7:xx.xx.x</code>相同即可。</p>
<p>不过此方法在编译后会引起androidTest包下的测试文件异常，不用的删除即可。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Error-Execution-failed-for-task-‘-app-prepareDebugAndroidTestDependencies’&quot;&gt;&lt;a href=&quot;#Error-Execution-failed-for-task-‘-app-prepareDebugAndroidTestDependencies’&quot; class=&quot;headerlink&quot; title=&quot;Error:Execution failed for task ‘:app:prepareDebugAndroidTestDependencies’.&quot;&gt;&lt;/a&gt;Error:Execution failed for task ‘:app:prepareDebugAndroidTestDependencies’.&lt;/h1&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="编译异常" scheme="https://maintel.github.io/tags/%E7%BC%96%E8%AF%91%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>git使用笔记</title>
    <link href="https://maintel.github.io//blog/2017/02/git%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0.html"/>
    <id>https://maintel.github.io//blog/2017/02/git使用笔记.html</id>
    <published>2017-02-15T08:06:05.000Z</published>
    <updated>2018-03-18T03:38:17.278Z</updated>
    
    <content type="html"><![CDATA[<p>平时工作git使用过程中的一些常用命令，或者遇到的一些问题，留作记录。</p>
<a id="more"></a>
<h1 id="切换账户"><a href="#切换账户" class="headerlink" title="切换账户"></a>切换账户</h1><h2 id="不用ssh切换账号"><a href="#不用ssh切换账号" class="headerlink" title="不用ssh切换账号"></a>不用ssh切换账号</h2><ul>
<li><p>查看本地的用户及邮箱</p>
<p>  <code>git config user.name</code></p>
<p>  <code>git config user.email</code></p>
</li>
<li><p>修改账户</p>
<p>  <code>git config --global user.name &quot;username&quot;</code></p>
<p>  <code>git config --global user.email &quot;email&quot;</code></p>
</li>
</ul>
<h1 id="新建、切换、合并分支"><a href="#新建、切换、合并分支" class="headerlink" title="新建、切换、合并分支"></a>新建、切换、合并分支</h1><ul>
<li><p>新建分支</p>
<p>  <code>git branch xxx</code></p>
</li>
<li><p>切换分支</p>
<p>  <code>git checkout xxx</code></p>
</li>
</ul>
<p>上面两条命令可以用一条命令实现<strong>新建并切换分支</strong></p>
<p> <code>git checkout -b xxx</code></p>
<ul>
<li><p>合并分支</p>
<p> 首先切换到需要合并到的分支，执行</p>
<p> <code>git merge xxx</code> xxx是需要合并过来的分支名</p>
</li>
</ul>
<h1 id="发生冲突"><a href="#发生冲突" class="headerlink" title="发生冲突"></a>发生冲突</h1><h2 id="内容冲突"><a href="#内容冲突" class="headerlink" title="内容冲突"></a>内容冲突</h2><p>出现冲突时会出现<strong>CONFLICT</strong>字样，而且此时分支并不是在某一分支而是在<strong>master|MERGING</strong>；</p>
<p><img src="http://orzoelfvh.bkt.clouddn.com/git%20%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81.png?attname=&amp;e=1498205923&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:p3zSW1cLxlaHROLLVYT_o1v_ym4" alt="git 内容冲突"></p>
<p>最简单的解决办法是查看冲突的文件，例如上图为<em>git test.txt</em>,打开后可以发现：</p>
<p><img src="http://orzoelfvh.bkt.clouddn.com/git%E5%86%85%E5%AE%B9%E5%86%B2%E7%AA%81%E5%86%85%E5%AE%B9.png?attname=&amp;e=1498206071&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:RLFdtKpKUIQVFYWOMg4mos0kllA" alt="git 内容冲突内容"></p>
<p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 中间就是发生冲突的地方，此时直接编辑冲突文件，然后把<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>以及中间的等号删除，然后再执行命令<code>git add .</code>以及<code>git commit -m &#39;注释&#39;</code>就解决了冲突。</p>
<h1 id="发生Please-enter-a-commit-message-to-explain-why-this-merge-is-necessary"><a href="#发生Please-enter-a-commit-message-to-explain-why-this-merge-is-necessary" class="headerlink" title="发生Please enter a commit message to explain why this merge is necessary."></a>发生Please enter a commit message to explain why this merge is necessary.</h1><p>这句话的意思就是需要提交消息解释为什么合并是必要的。</p>
<p>此时会弹出VIM界面如图：</p>
<p><img src="http://orzoelfvh.bkt.clouddn.com/%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81%E5%87%BA%E7%8E%B0vim.jpg?attname=&amp;e=1498206503&amp;token=cs2nCfx72Y7hW0_NpFYzb3Jab90IJWraRtphMd-q:SoFxxTDV6yk_odh48Ke-EsqRjEY" alt="合并冲出出现vim界面"></p>
<p>此时可以做如下操作</p>
<ul>
<li><p>按键盘字母 i 进入insert模式</p>
</li>
<li><p>修改最上面那行黄色合并信息,可以不修改</p>
</li>
<li><p>按键盘左上角”Esc”</p>
</li>
<li><p>输入”:wq”,注意是冒号+wq,按回车键即可</p>
</li>
</ul>
<p>退出这个界面的话按<code>ctrl + z</code>；</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平时工作git使用过程中的一些常用命令，或者遇到的一些问题，留作记录。&lt;/p&gt;
    
    </summary>
    
      <category term="工具与配置" scheme="https://maintel.github.io/categories/%E5%B7%A5%E5%85%B7%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="git" scheme="https://maintel.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>retrofit使用Body方式访问接口</title>
    <link href="https://maintel.github.io//blog/2017/02/retrofit%E4%BD%BF%E7%94%A8-body%E6%96%B9%E5%BC%8F%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3.html"/>
    <id>https://maintel.github.io//blog/2017/02/retrofit使用-body方式访问接口.html</id>
    <published>2017-02-12T08:24:02.000Z</published>
    <updated>2018-03-18T03:39:07.721Z</updated>
    
    <content type="html"><![CDATA[<p>当服务器接口使用<code>RequestBody</code>方式接收数据的时候。</p>
<a id="more"></a>
<h1 id="服务器更新了"><a href="#服务器更新了" class="headerlink" title="服务器更新了"></a>服务器更新了</h1><p>最近后台服务器调整使用<code>RequestBody</code>以及Json方式接受数据如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/login"</span>, method = RequestMethod.POST)</div><div class="line"><span class="meta">@ResponseBody</span></div><div class="line"><span class="function"><span class="keyword">public</span> GeneralResponse&lt;User&gt; <span class="title">login</span><span class="params">(@RequestBody GeneralRequest&lt;User&gt; request)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="使用-Body"><a href="#使用-Body" class="headerlink" title="使用@Body"></a>使用@Body</h1><p>项目原来使用的@Field形式参数请求后台的，但是改成@Body方式还是不能访问如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span>(value = <span class="string">"user/login"</span>)</div><div class="line">Observable&lt;BaseBean&lt;User&gt;&gt; login(<span class="meta">@Body</span> String parameter);</div></pre></td></tr></table></figure>
<p>原来后台是使用@RequestBody方式接收数据，直接解析Body中的json为一个对象来接收参数的。所以请求是body参数应该为<code>RequestBody</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@POST</span>(value = <span class="string">"user/login"</span>)</div><div class="line">Observable&lt;BaseBean&lt;User&gt;&gt; login(<span class="meta">@Body</span> RequestBody parameter);</div></pre></td></tr></table></figure>
<p>同时，需要将请求的参数组装成一个json，然后转成<code>RequestBody</code>方式来上传，于是写了一个通用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">RequestBody <span class="title">assRequestNoSession</span><span class="params">(T bean)</span> </span>&#123;</div><div class="line">    GeneralRequest&lt;T&gt; generalRequest = <span class="keyword">new</span> GeneralRequest&lt;&gt;();</div><div class="line">    generalRequest.setData(bean);</div><div class="line">    Gson gson = <span class="keyword">new</span> Gson();</div><div class="line">    <span class="keyword">return</span> RequestBody.create(MediaType.parse(<span class="string">"application/json"</span>), gson.toJson(generalRequest));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="添加请求头"><a href="#添加请求头" class="headerlink" title="添加请求头"></a>添加请求头</h1><p>但是修改以后还是不能成功访问后台，经过查阅资料发现因为后台是使用Json方式接受的，所以应该在请求头中添加<code>Content-Type: application/json</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Headers</span>(&#123;<span class="string">"Content-Type: application/json"</span>&#125;)</div><div class="line"><span class="meta">@POST</span>(value = <span class="string">"user/login"</span>)</div><div class="line">Observable&lt;BaseBean&lt;User&gt;&gt; login(<span class="meta">@Body</span> RequestBody parameter);</div></pre></td></tr></table></figure>
<p>这样倒可是访问后台了，但是为每一个接口都添加请求头不够优雅，因此想到了使用拦截器，在Okhttp中添加如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">OkHttpClient.Builder builder = <span class="keyword">new</span> OkHttpClient.Builder();</div><div class="line">builder.addInterceptor(<span class="keyword">new</span> Interceptor() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                Request newRequest = chain.request().newBuilder()</div><div class="line">                        .addHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</div><div class="line">                        .build();</div><div class="line">                <span class="keyword">return</span> chain.proceed(newRequest);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>这样，就可以正确的使用Body方式请求网络了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当服务器接口使用&lt;code&gt;RequestBody&lt;/code&gt;方式接收数据的时候。&lt;/p&gt;
    
    </summary>
    
      <category term="开源" scheme="https://maintel.github.io/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="Refrofit" scheme="https://maintel.github.io/tags/Refrofit/"/>
    
  </entry>
  
  <entry>
    <title>Retrofit、OKHttp访问接口时添加公共参数</title>
    <link href="https://maintel.github.io//blog/2017/02/Retrofit%E3%80%81OKHttp%E8%AE%BF%E9%97%AE%E6%8E%A5%E5%8F%A3%E6%97%B6%E6%B7%BB%E5%8A%A0%E5%85%AC%E5%85%B1%E5%8F%82%E6%95%B0.html"/>
    <id>https://maintel.github.io//blog/2017/02/Retrofit、OKHttp访问接口时添加公共参数.html</id>
    <published>2017-02-10T08:08:50.000Z</published>
    <updated>2018-03-18T03:39:10.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在实际的开发中，有时候后台需要在每个接口中带有一些公共的参数，比如当前APP的版本、访问时间、或者一些约定的秘钥等等，当然我们可以在每个接口中都添加这样的参数就可以了，但是那样做对一个程序员来说肯定不够优雅，所以就想怎么在接口请求的时候统一的对所有的接口加上这些参数。</p>
<a id="more"></a>
<h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>经过查阅资料发现可以使用OKHttp的拦截器(<code>Interceptor</code>)实现。</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><ul>
<li><p>新建一个<code>MyInterceptor</code>实现<code>Interceptor</code>接口；</p>
</li>
<li><p>重写<code>intercept</code>方法。</p>
</li>
</ul>
<h2 id="具体代码如下"><a href="#具体代码如下" class="headerlink" title="具体代码如下"></a>具体代码如下</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    Request request = chain.request();</div><div class="line">    RequestBody requestBody = request.body();</div><div class="line">    <span class="keyword">if</span> (request.method().equals(<span class="string">"GET"</span>)) &#123;</div><div class="line">        HttpUrl url = request.url();</div><div class="line"></div><div class="line">        Set&lt;String&gt; parameterNames = url.queryParameterNames();      <span class="comment">//</span></div><div class="line">        <span class="keyword">for</span> (String key : parameterNames) &#123;                          <span class="comment">//循环参数列表</span></div><div class="line">            <span class="keyword">if</span> (BuildConfig.DEBUG) Log.e(<span class="string">"MyInterceptor"</span>, key);      <span class="comment">// 如果要对已有的参数做进一步处理可以这样拿到参数</span></div><div class="line">        &#125;                                                            <span class="comment">//只添加的话 倒是没有必要</span></div><div class="line">        String sUrl = url.toString();</div><div class="line">        <span class="keyword">int</span> index = sUrl.indexOf(<span class="string">"?"</span>);</div><div class="line">        <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</div><div class="line">            sUrl = sUrl + <span class="string">"所需参数拼接"</span>;    <span class="comment">//所需参数拼接 ==&gt;就是类似于 name=123&amp;version=12&amp;....这些</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            sUrl = sUrl + <span class="string">"?"</span> + <span class="string">"所需参数拼接"</span>;</div><div class="line">        &#125;</div><div class="line">        request = request.newBuilder().url(sUrl).build();   <span class="comment">//重新构建</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.method().equals(<span class="string">"POST"</span>)) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (requestBody <span class="keyword">instanceof</span> FormBody) &#123;</div><div class="line">            FormBody.Builder builder = <span class="keyword">new</span> FormBody.Builder();</div><div class="line">            FormBody formBody = (FormBody) requestBody;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;    <span class="comment">// 如果要对已有的参数做进一步处理可以这样拿到参数</span></div><div class="line">                Log.e(<span class="string">"MyInterceptor"</span>, <span class="string">"encodedNames:"</span> + formBody.encodedName(i) + <span class="string">" encodedValues:"</span> + formBody.encodedValue(i));</div><div class="line">                builder.addEncoded(formBody.encodedName(i), formBody.encodedValue(i));</div><div class="line">            &#125;</div><div class="line">            builder.addEncoded(<span class="string">"参数1"</span>, <span class="string">"值1"</span>);  <span class="comment">//添加公共参数</span></div><div class="line">            builder.addEncoded(<span class="string">"参数2"</span>, <span class="string">"值2"</span>);</div><div class="line">            builder.addEncoded(<span class="string">"参数3"</span>, <span class="string">"值3"</span>);</div><div class="line">            request = request.newBuilder().post(builder.build()).build();  <span class="comment">//重新构建</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> chain.proceed(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在OKHttp或Retrofit中使用</li>
</ul>
<p>两者是一样的都是通过OKHttp来添加，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">        .addInterceptor(<span class="keyword">new</span> MyInterceptor())   <span class="comment">//使用拦截器</span></div><div class="line">        .connectTimeout(<span class="number">15</span>, TimeUnit.SECONDS).build();</div><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">        .client(okHttpClient)</div><div class="line">        .baseUrl(<span class="string">"http://192.168.1.59:8080/"</span>)</div><div class="line">        .addConverterFactory(GsonConverterFactory.create())</div><div class="line">        .build();</div><div class="line">networkService = retrofit.create(NetworkService.class);</div></pre></td></tr></table></figure>
<p>如上所示，就完成了普通的GET和POST方式使用时对所有的接口统一添加公共接口。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>本人最初是为了在访问后台接口的时候对所有的参数进行统一的加密，前后端使用同样的加密算法以及秘钥，但是在具体使用过程中如何传送秘钥，以及如何保证秘钥的传递安全以及加密算法的安全是需要重点考量的。<br>通过拦截器可以做很多事情，例如缓存等。</p>
<p>参考文章：</p>
<p><a href="http://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="external">http://www.jianshu.com/p/2710ed1e6b48</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h1&gt;&lt;p&gt;在实际的开发中，有时候后台需要在每个接口中带有一些公共的参数，比如当前APP的版本、访问时间、或者一些约定的秘钥等等，当然我们可以在每个接口中都添加这样的参数就可以了，但是那样做对一个程序员来说肯定不够优雅，所以就想怎么在接口请求的时候统一的对所有的接口加上这些参数。&lt;/p&gt;
    
    </summary>
    
      <category term="开源" scheme="https://maintel.github.io/categories/%E5%BC%80%E6%BA%90/"/>
    
    
      <category term="Refrofit" scheme="https://maintel.github.io/tags/Refrofit/"/>
    
  </entry>
  
  <entry>
    <title>NKD中使用第三方SO</title>
    <link href="https://maintel.github.io//blog/2017/01/NKD%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9SO.html"/>
    <id>https://maintel.github.io//blog/2017/01/NKD中使用第三方SO.html</id>
    <published>2017-01-17T08:05:26.000Z</published>
    <updated>2018-03-18T03:28:23.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在<code>Android</code>开发中有时会遇到使用<code>JNI</code>调用<code>C/C++</code>函数库的场景。一般这个时候都是使用<code>NDK</code>将<code>C/C++</code>源代码编译出<code>so</code>文件，然后进行调用。但是有时候会遇到另外的情况：</p>
<a id="more"></a>
<pre><code>我们在NDK项目中还要再引入其他第三方的SO库
</code></pre><p>这个时候该怎么编译呢？</p>
<pre><code>通过使用动态函数库的调用方法，直接包含其头文件，便可以直接调用库中的类和方法。
</code></pre><p>具体使用过程可以分为两步：</p>
<ul>
<li><p>编写JNI文件包含第三方库的头文件。</p>
</li>
<li><p>编写MK文件引入预编译库（即第三方库）。</p>
</li>
</ul>
<h1 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h1><p>拿现在项目中遇到的一个具体情景：</p>
<p>现在手头有一个USB设备，公司要求实现在<code>windows</code>、<code>Android</code>、<code>Linux嵌入式</code>三平台通用的USB驱动库，然后各个平台只用做小量修改即可使用。经过评估决定使用git上的一个开源项目<a href="https://github.com/libusb/libusb" target="_blank" rel="external">libusb</a>来实现，当然可以直接使用源码来编译一个so出来，但是这样不够B格，而且实际使用过程中还要引入另外一个库文件，所以这里使用上面说的方式来调用，如下。</p>
<h1 id="编写JNI文件"><a href="#编写JNI文件" class="headerlink" title="编写JNI文件"></a>编写JNI文件</h1><p>在要编写的源文件目录下新建<code>include</code>文件夹(其实这个随便)，将要使用的函数所在的头文件放入其中，如：libusb.h。</p>
<p>在我们的源码中包含这个头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/libusb.h"</span></span></div></pre></td></tr></table></figure>
<p>然后直接在需要使用的位置调用相应的函数即可：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT <span class="keyword">void</span> JNICALL <span class="title">Java_com_yannan_usbtest_UsbTest_libUsbInit</span></span></div><div class="line">        <span class="params">(JNIEnv *env, jclass jobj)</span> &#123;</div><div class="line">    <span class="keyword">if</span> (libusb_init(<span class="literal">NULL</span>) &lt; <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		LOGD(<span class="string">"VeinSensorBase::Open(): libusb_init() &lt;0\n"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="编译MK文件"><a href="#编译MK文件" class="headerlink" title="编译MK文件"></a>编译MK文件</h1><p>首先将第三方库作为预编译引入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LOCAL_PATH := $(call my-dir)  </div><div class="line"></div><div class="line">include $(CLEAR_VARS)  </div><div class="line">LOCAL_MODULE := usb_pre   </div><div class="line">LOCAL_SRC_FILES := usb/libusb-1.0.so           </div><div class="line">include $(PREBUILT_SHARED_LIBRARY)</div><div class="line"></div><div class="line"></div><div class="line">include $(CLEAR_VARS)  </div><div class="line">LOCAL_MODULE    := test </div><div class="line">LOCAL_SRC_FILES := usb_test.c</div><div class="line">LOCAL_SHARED_LIBRARIES := usb_pre</div><div class="line">LOCAL_LDLIBS := -llog  </div><div class="line">include $(BUILD_SHARED_LIBRARY)</div></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><p><code>LOCAL_MODULE := usb_pre</code> 给这个第三方库取一个名字，不需要与原来的名字相同</p>
</li>
<li><p><code>LOCAL_SRC_FILES := usb/libusb-1.0.so</code> 表示这个库的路径，是在MK文件的目录下的<code>usb</code>目录中</p>
</li>
<li><p><code>PREBUILT_SHARED_LIBRARY</code> 表示这是一个共享库，即so库。</p>
</li>
<li><p><code>LOCAL_SHARED_LIBRARIES := usb_pre</code> 这一步则表示此模块依赖于上面命名的预编译库。</p>
</li>
</ul>
<p>然后执行<code>ndk-build</code>编译即可，此时在libs文件夹中会生成两个so文件，分别为<code>libtest.so</code>和<code>libusb-1.0.so</code>,都拷贝到项目中就可以了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;在&lt;code&gt;Android&lt;/code&gt;开发中有时会遇到使用&lt;code&gt;JNI&lt;/code&gt;调用&lt;code&gt;C/C++&lt;/code&gt;函数库的场景。一般这个时候都是使用&lt;code&gt;NDK&lt;/code&gt;将&lt;code&gt;C/C++&lt;/code&gt;源代码编译出&lt;code&gt;so&lt;/code&gt;文件，然后进行调用。但是有时候会遇到另外的情况：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="JNI" scheme="https://maintel.github.io/tags/JNI/"/>
    
      <category term="NKD" scheme="https://maintel.github.io/tags/NKD/"/>
    
  </entry>
  
  <entry>
    <title>小心JNI中的内存泄露</title>
    <link href="https://maintel.github.io//blog/2017/01/%E5%B0%8F%E5%BF%83JNI%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.html"/>
    <id>https://maintel.github.io//blog/2017/01/小心JNI中的内存泄露.html</id>
    <published>2017-01-12T09:28:55.000Z</published>
    <updated>2018-03-13T14:46:37.020Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Jni频繁资源未释放引起的崩溃问题</title>
    <link href="https://maintel.github.io//blog/2017/01/Jni%E9%A2%91%E7%B9%81%E8%B5%84%E6%BA%90%E6%9C%AA%E9%87%8A%E6%94%BE%E5%BC%95%E8%B5%B7%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98.html"/>
    <id>https://maintel.github.io//blog/2017/01/Jni频繁资源未释放引起的崩溃问题.html</id>
    <published>2017-01-10T15:17:08.000Z</published>
    <updated>2018-03-18T03:28:31.784Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Failed-adding-to-JNI-pinned-array-ref-table-1024-entries"><a href="#Failed-adding-to-JNI-pinned-array-ref-table-1024-entries" class="headerlink" title="Failed adding to JNI pinned array ref table (1024 entries)"></a>Failed adding to JNI pinned array ref table (1024 entries)</h1><p><strong>问题重现:</strong></p>
<p>在开发蓝牙模块升级的时候， 由于要传送的升级文件较大，所以需要频繁的通过JNI调用C语言来组装报文，结果在低版本手机测试时遇到<code>Failed adding to JNI pinned array ref table (1024 entries)</code>.</p>
<a id="more"></a>
<p><strong>错误代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function">JNIEXPORT jbyteArray JNICALL <span class="title">xxx_BleUtils_sendUpdatePkt</span><span class="params">(</span></span></div><div class="line">        JNIEnv *env, jclass jobj, jbyteArray pkt, jint pkt_sn, jint pktLen, jint token</div><div class="line">) &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> outbuf[APPAPI_MAXSENDLEN / <span class="number">4</span>];</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *pBuffer = (*env)-&gt;GetByteArrayElements(env, pkt, <span class="literal">NULL</span>);   <span class="comment">//&lt;==引起错误的地方</span></div><div class="line">    <span class="keyword">int</span> ret = ynLockSendPkt((<span class="keyword">uint16_t</span>) token, (<span class="keyword">uint16_t</span>) pkt_sn, pktLen,</div><div class="line">                            pBuffer,</div><div class="line">                            (<span class="keyword">char</span> *) outbuf,</div><div class="line">                            APPAPI_MAXSENDLEN);</div><div class="line">    jbyteArray <span class="built_in">array</span> = (*env)-&gt;NewByteArray(env, ret);</div><div class="line">    (*env)-&gt;SetByteArrayRegion(env, <span class="built_in">array</span>, <span class="number">0</span>, ret, outbuf);</div><div class="line">    <span class="keyword">return</span> <span class="built_in">array</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>原因：</strong></p>
<p>运行 native method 的线程的堆栈记录着 Local Reference 表的内存位置（指针 p），Local Reference表中存放JNI Local Reference实现 Local Reference 到 Java 对象的映射，函数中调用的<code>GetByteArrayElements()</code>会使Local Reference表中的存放的指针加一，频繁的调用而得不到释放的话表中的值就会一直增加，直至内存被占满引起崩溃。</p>
<p><strong>解决方法：</strong></p>
<p>在函数中<code>return</code>前释放资源：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(*env)-&gt;ReleaseByteArrayElements(env,pkt, pBuffer, <span class="number">0</span>); <span class="comment">//pkt为java层传递过来的数组，pBuffer为指针</span></div></pre></td></tr></table></figure>
<p>由于是在JNI层发生的错误，而且项目只是集成了bugly在Java层面的错误收集，所以一直找不到崩溃原因，最后不得不找了同型号的手机来测试几遍才发现问题,看来BUG收集也要尽善尽美才行啊，不能偷懒。</p>
<p>只在低配手机出现没有在高配手机出现的原因应该是高配手机分配的内存更大。但是这里的内存只要不被释放，当以后升级包更大的时候总有一天高配手机也会出现问题的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Failed-adding-to-JNI-pinned-array-ref-table-1024-entries&quot;&gt;&lt;a href=&quot;#Failed-adding-to-JNI-pinned-array-ref-table-1024-entries&quot; class=&quot;headerlink&quot; title=&quot;Failed adding to JNI pinned array ref table (1024 entries)&quot;&gt;&lt;/a&gt;Failed adding to JNI pinned array ref table (1024 entries)&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;问题重现:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发蓝牙模块升级的时候， 由于要传送的升级文件较大，所以需要频繁的通过JNI调用C语言来组装报文，结果在低版本手机测试时遇到&lt;code&gt;Failed adding to JNI pinned array ref table (1024 entries)&lt;/code&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://maintel.github.io/categories/Android/"/>
    
    
      <category term="JNI" scheme="https://maintel.github.io/tags/JNI/"/>
    
  </entry>
  
</feed>
